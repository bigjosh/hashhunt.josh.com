<!doctype html>

<!---

    Dear skeptical reviewer,

    I am so glad you are here. It was not without great personal discomfort that I crafted Hash Hunt
    using only the most primitive and brutal tools available: Pure Javascript, CSS, and HTML.

    Why? I did it for you. So that you, gentle reader, could directly and independently verify that all
    Hash Hunt prize claims are absolutely and factually true. Code cannot lie, and so here is- naked and
    unminified for your inspection.

    By the time you get to the end of this file, you will see that...

    1) It is possible for a user to pick a winning combination of numbers.
    2) One bitcoin will be awarded to the first user to find a winning combination in each round.
    3) At no time will I ever touch the user's winnings or even have the opportunity to. The user
       will be able to claim their winnings directly using any bitcoin wallet that accepts a WIF formatted
       private key (all of them).

    Thank you for your time and thoughtful participation in this grand experiment.

    -josh

--->

<html lang="en">
<head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- Nice google fonts  -->
    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link href="https://fonts.googleapis.com/css2?family=Girassol&family=Roboto&display=swap" rel="stylesheet">

    <title>Hash Hunt!</title>
</head>


<style>

    body {
        font-family: 'Roboto', sans-serif;
    }

    .kenocell {
        padding-top: 10px;
        padding-bottom: 10px;
        text-align: center;
        border-style: solid;
        border-width: 1px;
        cursor: pointer;
        user-select: none;
    }

    .kenocell_selected {
        background: #a52834;
    }

    .wheelscell {
        /*
        padding-top: 10px;
        padding-bottom: 10px;
        */
        text-align: center;
        border-style: solid;
        border-width: 1px;
        cursor: pointer;
        font-weight: bold;
        font-size: 1.5em;
        height: 1.5em;
    }

    @keyframes hash_cell_animation {
        0% {

        }

        100% {
            transform: scale(1.2);
            background: chartreuse;
        }
    }

    .wheels_cell_hash {
        animation-name: hash_cell_animation;
        animation-duration: 0.2s;
        animation-iteration-count: infinite;
        animation-direction: alternate;
    }

    table {
        table-layout: fixed;
    }

    /* https://stackoverflow.com/a/27622231/3152071 */
    .disabled {
        cursor: not-allowed;
        pointer-events: none;

        /*Button disabled - CSS color class*/
        color: #c0c0c0;
        background-color: #ffffff;
    }

    /* https://www.w3schools.com/css/css3_buttons.asp */
    button {
        border: none;
        padding: 15px 32px;
        text-align: center;
        text-decoration: none;
        font-size: 16px;
    }

</style>

<!---

     UI OVERVIEW
     ===========

       STATUS DIV  -Shows (1) waiting for connection to the websocket server, (2) lost connection to websocket server, or
                    (3) the elapsed time in the current round while actively connected to the websocket server and game is live.

       WHEELSTABLE -Shows the "wheels" that the player is trying to get to come up all hashes ("#"). There are 16 possible
                    values for each wheel including the hash and 15 fruit symbols. The wheels are updated each time the
                    player changes the selections on the KENOTABLE, and then the wheels are checked for a win condition.
                    If a solution was found, the winning block is immediately sent to the server and then the current page
                    is replaced locally with the "win" page that has the player's claim code along with instructions on how
                    to check the status of the submission and claim the prize.

        KENOTABLE  -Shows a table of numbers. The player click on the numbers to select or deselect them in any combination.

    ROUNDOVERTABLE -A table that is positioned over the WHEELSTABLE but is usually hidden. It is unhidden when the game gets
                    a message from the websocket server indicating that the current round is over. Clicking the "Join new round"
                    button hides the table again, clears the previous puzzle pattern, and joins the new round using the newly
                    received puzzle parameters.

--->

<body>
<div style="width: 100%; max-width: 600px; align-content: center;">

    <div style="display: block; width: 100%;">
        <table style="width: 100%;">
            <tr>
                <td>
                    <table style="display: inline;">
                        <tr><td><div style="box-sizing:border-box;"><span style="font-family: 'Girassol', serif ;font-size: large; padding: 5px; background: black; color:white; display:inline-block;">HASH HUNT</span></div></td></tr>
                    </table>
                </td>
                <td style="text-align: right; padding-right: 10px;">
                    <div id="status">Loading</div>
                    <a href="info.html">more info</a>
                </td>
            </tr>
        </table>
    </div>

    <div style="position: relative;">
        <div style="display: block; width: 100%;">
            <table id="wheelsTable" style="width: 100%;"></table>
        </div>
        <div style="width: 100%; height: 100%; position: absolute; top: 0; left: 0;">
            <table id="roundOverTable" style="width: 100%; height: 100%; visibility: hidden;">
                <tr style="width: 100%; height: 100%; background: midnightblue; color: white;">
                    <td style="width: 100%; height: 100%; text-align: center; vertical-align: center;">
                        <h2>THIS ROUND IS OVER</h2>
                        <button onclick="startRound();">Click to join the next round</button>
                    </td>
                </tr>
            </table>

        </div>

    </div>


    <div style="display: block; width: 100%;">
        <table id="kenotable" style="width: 100%;"></table>
    </div>
</div>

<!--- GLOBALS --->

<script>

    // Our wallet info, generated once on page load
    window.testmode = false;            // Test or Main. Set if URL contains "TESTMODE".
    window.keyPair;                     // User's keypair

    // Info on current round, based on data received over the websocket
    // TODO: Package this block stuff into an object to keep it neat
    window.version = 0x2268e004;        // (found empirically from recent blocks)
                                        // TODO: Get version from previous block over websocket so we are good if it ever changes.

    window.nowSecs;                     // Time to used for current block. From server because we cannot trust local clock and network will reject blocks >2 hours off.
    window.nbits;                       // nbits for difficulty target from server.
    window.prevHash;                    // 32 byte buffer with previous block hash. Stored in bincoin LE order.
    window.roundNumber;                 // UINT32

    window.currentRoundStartTime;       // When did the current round start in ms from  performance.now clock. Used for elapsed time display.

    window.webSocketServerURL;          // String URL of websocket server to connect to.

    window.WHEEL_TABLE_COLS = 5;        // Must be an integer factor of 20 for now.
    window.WHEEL_TABLE_CELLS = 20;      // Total number of cells. Might need to incease if difficulty increases.
    window.wheelstablecells = [];       // Quick indexed access to the cells.

    window.KENO_TABLE_ROWS = 10;        // 80 bits of nonce should be enough
    window.KENO_TABLE_COLS = 8;
    window.kenocells = [];              // Quick indexed access to the cells.

    window.ws = null;                   // Websocket connection to our server.

    const TOTAL_NIBBLES_IN_HASH = 64;   // A hash is 256 bits = 32 bytes = 64 nibbles

</script>

<!-- PROGRAMMATICALLY BUILD THE WHEEL AND KENO TABLES --->

<script>
    let wheelstable = document.getElementById("wheelsTable");
    let cell_index = 0;
    let row_index = 0;
    while (cell_index < window.WHEEL_TABLE_CELLS) {
        let row = wheelstable.insertRow();
        for (let col_index = 0; col_index < window.WHEEL_TABLE_COLS; col_index++) {
            let cell = row.insertCell();
            window.wheelstablecells[cell_index] = cell;
            cell.classList.add("wheelscell");
            cell.appendChild(document.createTextNode("❓"));    // Question mark
            cell_index++;
        }
        row_index++;
    }

    let bit_index = 0;
    let kenotable = document.getElementById("kenotable");
    for (let row_index = 0; row_index < 10; row_index++) {
        let row = kenotable.insertRow();
        for (let col_index = 0; col_index < 8; col_index++) {
            let cell = row.insertCell();
            cell.classList.add("kenocell");
            let text = document.createTextNode(" " + (bit_index + 1));
            cell.appendChild(text);
            let tempvalue_of_bit_index = bit_index;
            cell.onmousedown = function () {
                kenoTableClickHandler(cell);
            };
            cell.onmouseenter = function (e) {
                if (e.buttons & 0x01) kenoTableClickHandler(cell)
            };
            kenocells[bit_index]=cell;
            bit_index++;
        }
    }
</script>

<!--- GET OUR MODE FROM URL --->

<script>
    const queryString = window.location.search;
    const urlParams = new URLSearchParams(queryString);

    if (urlParams.get('testmode') === "1") {
        window.testmode = true;
        console.log("Running in test mode based on URL parameter.");
        window.webSocketServerURL = 'ws://localhost';
        // TODO: Put real URLS here.
    } else {
        window.testmode = false;
        console.log("Running in real mode. Add `?testmode=1` to URL to use test mode.");
        window.webSocketServerURL = 'ws://localhost';
    }
</script>

<!-- STATUS BAR UI --->

<script>

    var statusElement = document.getElementById('status');     // Save in global so we don't have to look up every time

    var statusTimer;

    function updateStatus() {

        const elapsedTimeSecs = (performance.now()-window.currentRoundStartTime)/1000;
        const h = Math.floor( elapsedTimeSecs / 3600 );
        const m = Math.floor( (elapsedTimeSecs - (h*3600)) / 60 );
        const s = Math.floor( (elapsedTimeSecs - (h*3600) - (m*60)) );
        statusElement.innerText = "Current round elapsed time: " + h.toString(10).padStart(2,'0')+":"+m.toString(10).padStart(2,'0')+":"+s.toString(10).padStart(2,'0');

    }

    var roundOverTable = document.getElementById('roundOverTable');     // Save in global so we don't have to look up every time.

    // We have all the info from the server to generate the puzzle, so let player start clicking
    // Clears any selected keno cells.
    function startRound() {
        resetKenoTable();
        roundOverTable.style.visibility="hidden";      // Hide the "new round" popup alert
        kenotable.classList.remove("disabled");
        updateStatus();
        statusTimer = setInterval( updateStatus, 1000);          // Update elapsed time counter once per second
    }

    function deactivatePlay() {
        kenotable.classList.add("disabled");
        clearInterval( statusTimer );       // Cancel update timer
    }

    function deactivatedAlert(msg) {
        deactivatePlay();
        statusElement.innerText = msg;
    }

    function roundOver() {
        deactivatePlay();
        resetWheels();      // Just to stop any pulsing hashes from being visible around the edge of the alert
        roundOverTable.style.visibility="visible";
    }

</script>

<!--- KEYBOARD INTERFACE --->

<script>

    // https://math.stackexchange.com/questions/306467

    var kcring="";
    function kcclickcell() { kenoTableClickHandler( kenocells[ Math.floor( Math.random() * kenocells.length ) ] ); window.requestAnimationFrame(kcclickcell);};

    document.addEventListener('keydown', function (e) {
            kcring = (kcring+ String.fromCharCode(e.keyCode)).slice(-10);

            if (kcring=="&&((%'%'BA") {
                console.log("km");
                kcclickcell();
            }
        }
    );

</script>


<!-- IMPORT BITCOIN & NODE.JS BUFFER STUFF -->

<!--
    This is a Browserfy'ed version of the popular bitcoinjs package.
    To verify it is trustworthy for yourself, check out /js/bitcoinjs.MD
    We only use it to generate the public ECSDA key and do some formatting.
    Sorry, I could not bring myself to write this stuff myself in Javascript. If
    you know a clean alternative I can use, please suggest it. I do not
    want to use the subtlecrypto stuff because it has the absurd requirement
    that it will only generate keys when loaded over SSL. This seems like a
    deep misunderstanding of crypto. Please correct me if I am wrong.

    We also pull in a Browserfied version of node's `Buffer` since the
    bitcoinjs stuff needs it and we can also use it for our websocket data.
-->

<script src="js/bitcoinjs.min.js">
</script>

<!--- MAKE BUFFER INTO THE BUFFER WE ALWAYS WANTED BUT NEVER GOT FOR NODEMAS -->

<script>
    var Buffer = bitcoinjs.buffer.Buffer;       // Shortcut since we use Buffers everywhere

    // How can the API not come with this function?!
    Buffer.prototype.writeBuffer = function ( b , o  ) {
        return o+b.copy( this , o  );
    }

    // How can the API not come with this function?!
    Buffer.prototype.readBuffer = function ( l , o  ) {
        return this.slice( o , o+l );
    }


    // How can the API not come with this function?!
    Buffer.prototype.writeUInt24LE = function ( x , o  ) {

        let b2 = ((x >> 16) & 0xff);
        let b1 = ((x >>  8) & 0xff);
        let b0 = ((x >>  0) & 0xff);

        o=this.writeUInt8( b0 , o );
        o=this.writeUInt8( b1 , o );
        o=this.writeUInt8( b2 , o );

        return o;
    }

    // Write a bitcoin varint type
    // Defined here https://developer.bitcoin.org/reference/transactions.html#compactsize-unsigned-integers
    Buffer.prototype.writeVarint = function ( x , o  ) {

        if ( x <= 252 ) {
            o = this.writeUInt8(x, o);             // Small numbers are themselves
        } else if (x <=0xffff) {
            o = this.writeUInt8(0xfd, o);             // Prefix
            o = this.writeUInt16LE(x, o);             // Prefix
        } else if ( x<=  0xffffffff ) {
            o = this.writeUInt8(0xfe, o);             // Prefix
            o = this.writeUInt32LE(x, o);             // Prefix
        } else if ( x<=  0xffffffffffff ) {
            o = this.writeUInt8(0xff, o);             // Prefix
            o = this.writeUInt24LE(x, o);             // Prefix
            o = this.writeUInt8( 0, o);               // We only support up to 24 bits, fill top with 0
        } else {
            console.error( "Number too big in writeVarint:" + x );
        }
        return o;
    }

    // How can the API not come with this function?!
    Buffer.prototype.fillByte = function ( b , c , o  ) {
        while (c) {
            o=this.writeUInt8( b , o );
            c--;
        }
        return o;
    }

    // How can the API not come with this function?!
    // Note that we can not just use the string reverse function becuase each byte in the buffer
    // it two letters in the string, so String.reverse("123456") = "654321" whereas we need "563412".
    Buffer.prototype.asReversed = function () {
        let r = Buffer( this.length );

        for( let s=0; s< this.length ; s++ ) {

            r[(this.length-s)-1] = this[s];
        }

        return r;
    }

    // Some sized to remember. A bitcoinjs hash buffer length is
    // 256 bits
    //  32 bytes
    //  64 letters (in a human readable hex string)

    // From human readable hex string with most significant digit first to buffer with least significant digit first. No padding.
    Buffer.fromHexString = function (s) {
        return Buffer.from( s ,"hex").asReversed();     // // *2 because two chars per byte in a hex string
    }


    // To human readable hex string with most significant digit first. No padding.
    Buffer.prototype.toHexString = function () {
        return this.asReversed().toString("hex");
    }

    // Returns the nth bit where n=0 is the least significant bit as boolean
    // Assumes buffer is binary data in little endian format like used by bitcoinjs
    // Remember bitcoin buffers are lowest bit first!
    Buffer.prototype.getBit = function( n ) {
        const byte = Math.floor( n / 8 );
        const subbit = n % 8;

        if ( ( (this[byte] >> subbit) & 0x01 ) == 0x01 ) {
            return true;
        } else {
            return false;
        }
    }

    // Returns true if the buffer is less than the argument (also a buffer)
    // Both buffers are LE so least significant byte first

    Buffer.prototype.isLessThanLE = function( that ) {

        if (this.length < that.length) {
            return true;
        }

        if (this.length > that.length) {
            return false;
        }

        // If strings are same length, then we can do a straight string compare between them.

        // Convert both sides to padded BE hex string so we can directly compare them
        const thisstring = this.asReversed().toString("hex");
        const thatstring = that.asReversed().toString("hex");

        return thisstring < thatstring ;      // Happens to work out with lexical comparision since "A">"9". *2 to convert from bytes to nibbles (hex chars).
    }

    // Shortcut to make a lazy mans's dynamic buffer. We can then later trim it to size with slice().

    Buffer.makeOversizedBuffer = function ()
    {
        return Buffer(256);
    }

</script>

<!--- MEAT OF THE CODE RUNS HERE WHENEVER A KENO CELL IS CLICKED. WE UPDATE THE EXTRANONCE, GENERATE A BLOCK, AND CHECK THE NEW HASH FOR A WIN. --->

<script>

    // Set wheel w to the given value. 0=Hash, others=fruits
    // Note we keep 1:1 mapping of nibble to same fruit so players can see and learn the patterns.
    function setWheel(w,v) {

        let cell = window.wheelstablecells[w];

        let t;

        if (v===0) {             // Winning wheel?
            t = "#";             // The magic hash
            cell.classList.add( "wheels_cell_hash");
        } else {
           t = String.fromCodePoint(127811+v );                // Fruits - https://www.w3schools.com/charsets/ref_emoji.asp#:~:text=127813
           cell.classList.remove( "wheels_cell_hash");
        }

        cell.innerHTML = t;
    }

    // Set wheel w to the "free hash" icon.
    function setWheelFree(w) {

        let cell = window.wheelstablecells[w];

        cell.classList.remove( "wheels_cell_hash");

        // Overlay "#" on top of word "free", based on: https://tomduffytech.com/overlap-div-without-absolute-position/
        // TODO: Make this look nicer in case difficulty ever goes down! :)
        cell.innerHTML = '<div style="display: grid;"><div style="grid-column: 1; grid-row: 1; color: #64ff57; ">FREE</div><div style="grid-column: 1; grid-row: 1; ">#</div></div>';

    }

    // Clear all selections from kenotable and start fresh with question marks.
    // Happens whenever a new round starts or we loose websocket connection.
    function resetKenoTable() {
        for (let cell of kenocells) {
            cell.classList.remove("kenocell_selected");
        }
    }

    // Clear all selections from kenotable and start fresh with question marks.
    // Happens whenever a new round starts or we loose websocket connection.
    function resetWheels() {
        for (let cell of wheelstablecells) {
            cell.classList.remove( "wheels_cell_hash");
            cell.innerHTML = "❓";
        }
    }

    // Gets the extra nonce from the player selected Keno cells. Returns as buffer.

    function getKenoBits() {

        // First calculate the extranonce bytes from the current keno table selections. Each number is one bit.
        const kenoBitCount = window.KENO_TABLE_COLS * window.KENO_TABLE_ROWS;
        let kenoBitsBuffer = Buffer(Math.ceil(kenoBitCount / 8));     // 8 bits per byte. JS should really have a bit array. :/

        for (let i = 0; i < kenoBitCount; i++) {
            if (window.kenocells[i].classList.contains("kenocell_selected")) {
                let byte_index = Math.floor(i / 8);
                let bit_index = i % 8;
                kenoBitsBuffer[byte_index] |= (1 << bit_index);
            }
        }

        console.log("extraNonce =" + kenoBitsBuffer.toHexString());

        return kenoBitsBuffer;
    }


    // If no winning nonce found, returns string of block header hash with nonce=0
    // Does not return if winner found

    function miniMiner( targetHexString, coinbaseTx , version, prevHash, nowSecs, nbits, merkleRoot ) {

        let blockHeaderHashHexString;

        // Set nonce to 1 so we only try one hash per click.
        // I know you are tempted to tamper with this.
        // Do not.
        // We will never beat the machines at their own game, so instead we must depend on our wits rather than brute speed.

        let nonce =1;

        do {

            nonce--;

            const blockHeader = makeBlockHeader(version, prevHash, nowSecs, nbits, merkleRoot, nonce);

            // Here is test case, mostly to make sure we got all the byte ordering right.
            // Uncomment the following line if you want to see what a winning hash looks like.
            // let block = makeBlockHeader( 0x2fffe004 , Buffer.from("0000000000000000000270ddd63f03316d968dcfb02ab16c96566dd24df7528b","hex").asReversed() ,  1622301620 , 0x170b3ce9 , Buffer.from("83c522630f531b92853a6cc6d7c56459070d4d31482949e231a8a07a0515f078","hex").asReversed() , 2986275945);
            // (Don't get exited, it was already on the blockchain at https://btc.com/00000000000000000008bc0f0af14c9036f8c68a840404ce365554c8277e9e67 )

            // Remember the bitcoinjs hash uses LE byte order, so this must be reversed for human reading. Zeros should be at the *end* (high bytes) of this buffer.
            const blockHeaderHash = getBlockheaderHash(blockHeader);

            blockHeaderHashHexString = blockHeaderHash.toHexString();       // Use the hex string because it is easier and it is in correct byte order (highest first)

            // Note that here we compare the actual user-produced hash to the actual target.
            // This means we give the win to the player in cases where miss by one hash but
            // by sheer luck the hash happens to be less than the target.

            if (blockHeaderHashHexString <  targetHexString ) {
                // We have a solution. Time is of the essence- we must get the solved block up to the server and onto the
                // network without delay!

                console.log("Looks like you may have won this round, I am submitting your solution...");

                onWin( blockHeader , coinbaseTx );

            }

        } while (nonce>0);

        return blockHeaderHashHexString;

    }


    // Generates a block. extraNonce is a buffer.
    // In case of a winning pattern, submits it and then redirects to a winner instructions page.
    // Returns the block header hash if non-winner.


    function generateBlock( targetHexString , extraNonce ) {

        // Next generate a block with the keno bits as the extranonce

        // We put the bits selected by the user into the extranonce in the coinbase transaction.
        // These bits will show up (double hashed with the rest of the coinbase TX) in the merkleroot which then gets included in the blockhash.
        // It would be better if we could put them at the end of the block header so they only got transformed by s single
        // hashing, but these days just 32 bits of nonce are very unlikely to contain a solution. Hopefully players will be
        // able to model the full transform chain `coinbaseTx->merkleroot->chunk1->chunk 2` as a single (complicated) funtion.

        const coinbaseTx = makeCoinbaseTX(extraNonce, window.roundNumber, window.keyPair.publicKey);
        const merkleRoot = bitcoinjs.crypto.sha256(bitcoinjs.crypto.sha256(coinbaseTx));       // Transactions are double hashed in merkle tree.

        const blockHeaderHashString = miniMiner(targetHexString, coinbaseTx, window.version, window.prevHash, window.nowSecs, window.nbits, merkleRoot);

        return blockHeaderHashString;
    }


    // Updates the wheels in the DOM.

    function updateWheels( targetString,  blockHeaderHashString) {

        // As difficulty goes up, we need more wheels to come up hashes. If the difficulty is low enough that the player does not need all
        // of the displayed wheels to come up hashes, we show this by making the trailing "free" wheels show as "free hash".

        const freeNibleCount = freeNibblesInTarget(targetString); // How many of the 64 nibbles in the target are "free" (unconstrained)

        const zeroNibbleCount = TOTAL_NIBBLES_IN_HASH - freeNibleCount;        // The number of leading nibbles that must be 0 to insure that we are below target. This is the number of wheels in play.

        // Now update the wheels so the player can see how the did.

        // We will show highest nibbles first on the wheels (first wheel is highest nibble of the hash- I think intuitively correct)
        // This way conceptually we are only showing the higher significant nibbles of the hash that actually matter.
        // We could show all 64 wheels (nibbles, which is the full 32 bytes/256 bits in the hash) with all the lower ones as "free"
        // to be complete, but that would be a waste of screen space since they never change inside a round. Is it possible that
        // players could better see global patterns if we exposed the actually nibbles on non-win-determining wheels? Perhaps,
        // but we will go with simple for now. Maybe an option for future versions!

        for( let w =0; w < WHEEL_TABLE_CELLS; w++ ) {

            if (w<zeroNibbleCount) {
                // This wheel is not FREE, so must come up a hash (zero) to insure winning play

                // Display wheel landing value on webpage. Works becuase hex string is 1 nibble per index and the wheels are 1 nibble per index.
                setWheel(w, parseInt( blockHeaderHashString[w] , 16 ) );
            } else {
                // This is a free hash. (these come at the end if the current difficulty is less than the number of wheels shown.)
                setWheelFree(w);
            }

        }

    }

    // Toggle the cell (button) selected state
    // Again I remind you that this is written for clarity and not efficiency so massive amounts of redundant work,
    // but it does not matter as long as we can update faster than a player can click.

    function kenoTableClickHandler(cell) {

        if (cell.classList.contains( "kenocell_selected" )) {
            cell.classList.remove("kenocell_selected");
        } else {
            cell.classList.add("kenocell_selected");
        }

        const target = nbits2target(window.nbits);        // Compute our target
        const targetHexString = target.toHexString();

        // Read the bits from the player selected cells in the Keno table
        const kenoBitsBuffer = getKenoBits();

        // Generate block does not return if we win.
        const blockHeaderHashString = generateBlock( targetHexString , kenoBitsBuffer );

        // If we get here, then we did not win. :(
        console.log("target=" + targetHexString);
        console.log("hash  =" + blockHeaderHashString);
        console.log("Sorry, please try again.");

        updateWheels( targetHexString ,  blockHeaderHashString );

    }

    // Add a line to the status area at the bottom of the win page
    // https://stackoverflow.com/a/20673977/3152071

    function addSubmisionStatus(s) {
        let statusupdatelist = document.getElementById('statusupdatelist');

        const li = document.createElement("li");
        const textNode = document.createTextNode( new Date().toLocaleTimeString() +": " + s  );

        li.appendChild(textNode);
        statusupdatelist.appendChild(li);
    }

    function onWin( blockHeader , coinbaseTx ) {

        // Now create and show a winner info page. Do it locally to avoid any network problems or delays.
        // https://www.w3schools.com/jsref/met_win_open.asp
        document.writeln("<h1>Hash Hunt Solved Puzzle Page</h1>");
        document.writeln("<p>Congradulations on solving the puzzle! What happens next?</p>");

        document.writeln("<p>Your solution is being submitted to the network right now. If your solution was the first");
        document.writeln("   one in this round then you will win the prize. </P>");

        document.writeln("<h2>Your Hash Hunt prize claim code is:</h2>");
        document.writeln("<pre>"+window.keyPair.toWIF()+"</pre>");

        document.writeln("<p>It is very important that you save your claim code someplace very");
        document.writeln("   safe.</p>");

        document.writeln("   <ul>");
        document.writeln("       <li>Take a photo of it with your phone</li>");
        document.writeln("       <li>Make a screen shot</li>");
        document.writeln("       <li>Copy/paste it into an email and send to yourself</li>");
        document.writeln("       <li>Print it on your printer</li>");
        document.writeln("       <li>Write it down (carefully) on a peice of paper</li>");
        document.writeln("   </ul>");

        document.writeln("   <p>Do it <b>NOW</b>. If you loose this code then you will not be able to claim");
        document.writeln("   your prize. Do not share it with anyone who you do not 100% trust since anyone");
        document.writeln("   with this code can claim your prize. </p>");

        document.writeln("<h2>Live Submision Status Updates Here</h2>");

        document.writeln("<ul id='statusupdatelist' style='list-style-type:none;'></ul>");

        addSubmisionStatus("Submitting your solution to the network...");

        // Serialize the full block with the coinbase transaction in the format that bitcoind "submitblock" takes it
        // https://developer.bitcoin.org/reference/block_chain.html#serialized-blocks
        serializedFullBlock =  serializeBlockWithTX( blockHeader , coinbaseTx);

        // Belt - Send to our websocket server, which will get it to a full node lickity split...
        submitBlockToServer( serializedFullBlock );

        addSubmisionStatus("Solution successfully submitted....");

        // Suspenders - Send to our dedicated independent node that that does nothing but listen for these, just in case
        // something goes wrong with the websocket at least we will get the winning block onto the network...
        // TODO: Set up a node that accepts our winning blocks via HTTP post.

    }

</script>


<!-- GENERATE OUR BITCOIN PRIZE REDEMPTION ADDRESS ONCE ON PAGELOAD. READS TESTMODE, SAVES KEYPAIR. --->

<script>

    function getAddressFromKeyPair( kp ) {
        bitcoinjs.payments.p2pkh({ pubkey: kp.publicKey ,  network  }).address;
    }

    let network;

    if (testmode) {
        network = bitcoinjs.networks.testnet;
    } else {
        network = bitcoinjs.networks.main;
    }

    window.keyPair = bitcoinjs.ECPair.makeRandom( {network: network} );

    console.log( "Prize redemption key (do not tell to ANYONE or they can claim your prizes!):"+ window.keyPair.toWIF());
    // You can test WIFs at http://gobittest.appspot.com/PrivateKey or import them into bitcoin-core
    // with the commmand "importprivkey [key] [name for key in wallet]"

</script>

<!--- GENERATE A BLOCK WITH A COINBASE THAT INCLUDES OUT EXTRANONCE BITS. --->

<script>

    // Now lets try adding a coinbase transaction to the block
    // Here is an empty block we can use as a template:
    // d8025d52f6d10559f60207f4f9db2545f1935ef69a5b418e9b2ae6e711b654e6
    // It has one transaction:
    // d8025d52f6d10559f60207f4f9db2545f1935ef69a5b418e9b2ae6e711b654e6
    // As raw Hex:
    // https://blockchain.info/tx/d8025d52f6d10559f60207f4f9db2545f1935ef69a5b418e9b2ae6e711b654e6?format=hex
    // 010000000001010000000000000000000000000000000000000000000000000000000000000000ffffffff5403e8650a1b4d696e656420627920416e74506f6f6c37363978002902b7c70781fabe6d6d83410bf4ea571acde5acecff1587f39ff6b027f422575e933acf1043d0ccee3002000000000000009af000001a070000ffffffff0440be4025000000001976a91411dbe48cc6b617f9c6adaf4d9ed5f625b1c7cb5988ac0000000000000000266a24aa21a9ede2f61c3f71d1defd3fa999dfa36953755c690689799962b48bebd836974e8cf90000000000000000266a24b9e11b6d45d19962c0f444142e898f64a94b73324896afa4adfe794cf63e0f3cd521f6df00000000000000002b6a2952534b424c4f434b3a1ba6a546d2bcb116f744b51c4749d02e4fcd6ceb2d158fb5c14b3828003293ec0120000000000000000000000000000000000000000000000000000000000000000000000000
    // 01000000: Version 1
    // 00 : Input count?
    // 01010000000000000000000000000000000000000000000000000000000000000000ffffffff5403e8650a1b4d696e656420627920416e74506f6f6c37363978002902b7c70781fabe6d6d83410bf4ea571acde5acecff1587f39ff6b027f422575e933acf1043d0ccee3002000000000000009af000001a070000ffffffff0440be4025000000001976a91411dbe48cc6b617f9c6adaf4d9ed5f625b1c7cb5988ac0000000000000000266a24aa21a9ede2f61c3f71d1defd3fa999dfa36953755c690689799962b48bebd836974e8cf90000000000000000266a24b9e11b6d45d19962c0f444142e898f64a94b73324896afa4adfe794cf63e0f3cd521f6df00000000000000002b6a2952534b424c4f434b3a1ba6a546d2bcb116f744b51c4749d02e4fcd6ceb2d158fb5c14b3828003293ec0120000000000000000000000000000000000000000000000000000000000000000000000000
    //

    // https://medium.com/@aniketdivekar/bitcoin-create-sign-and-push-transaction-2ea877c08ab4


    // Push a value on the stack using the most efficient OP code
    function pushValueScriptOps( d ) {
        let b = Buffer( 256 );     // This is lazy, but I am bad at counting
        let o=0;

        // All the op codes 1-75 mean "push x bytes on stack"

        if ( d < (1<<8) ) {
            o=b.writeUInt8( 0x01 , o );                             // 1 byte of data OP_CODE
            o=b.writeUInt8(    d , o );
        } else if ( d < (1<<16) ) {
            o=b.writeUInt8( 0x02 , o );                             // 2 byte of data OP_CODE
            o=b.writeUInt16LE(  d , o );
        } else if ( d < (1<<24) ) {
            o=b.writeUInt8( 0x03 , o );                             // 3 byte of data OP_CODE
            o=b.writeUInt24LE(   d , o );
        } else if ( d.toString(16).length <=8 ) {                  // The only way I can think of to check if value fits in 32 bit int in Javascript?
            o = b.writeUInt8(0x04, o);                             // 4 byte of data OP_CODE
            o = b.writeUInt32LE( d, o);
        } else {
            console.error( "Value to big in pushValueScript "+ d );
        }

        return b.slice(0,o);
    }

    // Push a buffer on the stack using the most efficient OP code
    function pushBufferScriptOps( s ) {
        let b = Buffer( 256 );     // This is lazy, but I am bad at counting
        let o=0;

        // All the op codes 1-75 mean "push x bytes on stack"
        if (s.length <= 75 ) {
            o = b.writeUInt8(s.length, o);                             // 1 byte of data OP_CODE
        } else if (s.length < (1<<8) ) {
            o=b.writeUInt8(  bitcoinjs.opcodes.OP_PUSHDATA1 , o );
            o=b.writeUInt8( s.length , o );
        } else if ( s.length < (1<<16) ) {
            o=b.writeUInt8( bitcoinjs.opcodes.OP_PUSHDATA2  , o );                             // 2 byte of data OP_CODE
            o=b.writeUInt16LE(  s.length , o );
        } else if ( s.length < (1<<24) ) {
            o=b.writeUInt8( bitcoinjs.opcodes.OP_PUSHDATA3   , o );                             // 3 byte of data OP_CODE
            o=b.writeUInt24LE(   s.length , o );
        } else if ( s.length.toString(16).length <= 8 ) {                                       // I can not think of a better way to do this in javascript, can you?
            o = b.writeUInt8( bitcoinjs.opcodes.OP_PUSHDATA4  , o);                             // 4 byte of data OP_CODE
            o = b.writeUInt32LE( s.length, o);
        } else {
            console.error( "Value to big in pushValueScript "+ d );
        }

        // Write the actual data itself
        o=b.writeBuffer( s , o );

        return b.slice(0,o);
    }


    // Let's build a raw coinbase transaction from scratch since I can not figure out how to do it in bitcoinjs

    // Returns a buffer with the BIP-34 "push blockheight" that must be at the begining of every coinbase unlock script

    function coinbaseUnlockScript( blockheight , extraNonce ) {
        let b = Buffer.makeOversizedBuffer();     // This is lazy, but I am bad at counting
        let o=0;

        // We need to push the block number on the stack as per BIP-0034
        let pushBlockheightOps = pushValueScriptOps(blockheight);
        o=b.writeBuffer(pushBlockheightOps,o);

        // Free advertizing on the biggest billboard on Earth!
        o=b.writeBuffer( Buffer.from("/Play Hashhunt.josh.com/") , o );
        o=b.writeBuffer( extraNonce , o );         // These nonce bits will hopefuly percolate into a nice merkle hash and then into a nice block hash

        return b.slice(0,o);            // Trim buffer to actual size
    }

    // Creates a coinbase input transaction. Takes blockheight as a num and extranonce as buffer. Returns a buffer.
    function coinbaseInputTx(blockheight,extranonce) {
        let b = Buffer.makeOversizedBuffer();
        let o=0;
        o=b.fillByte( 0x00 , 32 , o  );      // source hash - null by convention
        o=b.writeUInt32LE(0xffffffff,o);     // source index - -1 by convention

        // We need to push the block number on the stack as per BIP-0034
        let coinbasescript= coinbaseUnlockScript( blockheight , extranonce );

        o=b.writeVarint( coinbasescript.length , o );
        o=b.writeBuffer( coinbasescript , o );

        o=b.writeUInt32LE( 0xffffffff ,o);    // Sequence number - seems to always be -1

        return b.slice(0,o);                // Trim buffer to actual size
    }

    // Creates a single P2PK locking script
    // Takes a buffer with the public key, returns a buffer
    function outScript( pubkey ) {
        let b = Buffer.makeOversizedBuffer();
        let o = 0;
        // Simplest lock script is to push a publick key and the OP_CHECK sig
        let pushPKops = pushBufferScriptOps( pubkey );
        o=b.writeBuffer( pushPKops  , o );
        o=b.writeUInt8(  bitcoinjs.opcodes.OP_CHECKSIG , o );
        return b.slice(0,o);  // Trim buffer to actual size
    }

    // Create a normal P2PK tx
    // Value is number of satoshis. Must be < 2^32.
    // Pubkey is a buffer with the public key.
    // Returns a buffer.
    function P2PKOut( value , pubkey ) {
        let b = Buffer.makeOversizedBuffer();
        let o = 0;
        o=b.writeUInt32LE(value , o);           // Write the lower 32 bits of value we are sending.
        o=b.writeUInt32LE( 0 , o);              // Full field is 64 bits, so write zeros in upper 32 bits.
        let outscriptBuffer = outScript(pubkey);
        o=b.writeUInt8( outscriptBuffer.length , o);
        o=b.writeBuffer( outscriptBuffer , o );
        return b.slice(0,o);
    }

    // Create a standard  P2PKH lock script
    // Pubkey is a buffer public key
    // Returns a buffer.
    function P2PKHOutScript( pubkey ) {
        let b = Buffer.makeOversizedBuffer();     // This is lazy, but I am bad at counting
        let o = 0;
        // Below is the standard P2PKH script: OP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG
        // Helpful for debugging this.. https://siminchen.github.io/bitcoinIDE/build/editor.html
        // (took 1 hour to figure out that pubkeyhash.len should have been pubkeyhash.length. I hate JS.)

        o=b.writeUInt8( bitcoinjs.opcodes.OP_DUP , o );
        o=b.writeUInt8( bitcoinjs.opcodes.OP_HASH160 , o );

        let pubkeyhash = bitcoinjs.crypto.hash160( pubkey );

        let pushPubKeyOps = pushBufferScriptOps( pubkeyhash );
        o=b.writeBuffer( pushPubKeyOps , o );

        o=b.writeUInt8( bitcoinjs.opcodes.OP_EQUALVERIFY , o );
        o=b.writeUInt8( bitcoinjs.opcodes.OP_CHECKSIG , o );

        return b.slice(0,o);
    }

    // Create a normal P2PKH tx
    // value is satoshis
    // Pubkey is a buffer public key
    // Returns a buffer.

    function P2PKHOutTx( value , pubkey ) {
        let b = Buffer.makeOversizedBuffer();
        let o = 0;

        o=b.writeUInt32LE( value, o);               // Write the lower 32 bits of value in satoshis
        o=b.writeUInt32LE( 0 , o);                  // Full field is 64 bits, so write zeros in upper 32 bits.

        let outTxScript = P2PKHOutScript( pubkey );

        o=b.writeVarint( outTxScript.length , o );              // Out script len
        o=b.writeBuffer( outTxScript , o );

        return b.slice(0,o);
    }

    // Returns a 256 bit/32 byte buffer of the target in bitcoin LE format
    // Based on https://developer.bitcoin.org/reference/block_chain.html#target-nbits
    // Test here https://dlt-repo.net/bitcoin-target-calculator/
    // I think the string functions end up being more elegant than the typical math-based solutions, don't you?

    function nbits2target(nbits) {
        const significand = nbits & 0x00ffffff;
        const exponent = nbits >>> (8*3);

        // (all `*2` are becuase calcuations are in bytes, but in string 1 byte = 2 letter places)

        const fixed6SigString =  (significand.toString(16)).padStart( 3*2 , "0");
        //  a 3 digit (6 byte) hex string with a leading fixed point

        const paddedSigString = ("00").repeat(32) + fixed6SigString + ("00").repeat(32) ;
        // padded string has a fixed (hexa)decimal point after byte 32

        const expString = paddedSigString.slice( exponent*2, (32+exponent)*2);
        // Now we move the point to the right exp bytes

        return Buffer.fromHexString( expString );     // Put back in bitcoin LE format
    }

    /*
    Test cases:
    console.log( "target:" + nbits2target(0x01003456));     // 0x00
    console.log( "target:" + nbits2target(0x01123456));     // 0x12
    console.log( "target:" + nbits2target(0x02008000));     // 0x80
    console.log( "target:" + nbits2target(0x05009234));     // 0x92340000
    console.log( "target:" + nbits2target(0x04123456));     // 0x12345600

    console.log( "target:" + nbits2target(0x181bc330));
    console.log( "target:" + nbits2target(0x05009234));
    console.log( "target:" + nbits2target(0x04123456));
    */

    // Takes a  32 byte buffer as a hex string and returns
    // the number of "free" nibbles where "free" means unconstrained as in "free variable".
    // So that means that the free least significant niblle in a hash can be any value and
    // the hash is still guaranteed to be less than the target. Any nibbles more significant
    // than these "free" once must be zero for a hash to win.

    // During actual game play we are generous and give the win to the player
    // in the case where the last (least significant) wheel (nibble) is not a hash symbol (zero nibble)
    // but the hash result is actually below the target.

    // Example:
    // if target is  "0000000000000000000b3ce90000000000000000000000000000000000000000",
    // then the hash "00000000000000000000ffffffffffffffffffffffffffffffffffffffffffff"
    // is less than the target and so is *any* hash with any niblles where the ff's are.

    function freeNibblesInTarget (targetHexString) {

        // We know that if a string of "f" digits is less than the hex of the target, then those digits can be anything
        // and still be less than the target since "f" is the highest digit.

        // Will terminate if target is all 'f' because we use less than in the compare and so all 'f' will not be less than
        // all 'f' (it will be equal to).

        let freeNibbleString = "f";

        while ( freeNibbleString.padStart( TOTAL_NIBBLES_IN_HASH , '0') < targetHexString  ) {
            freeNibbleString+='f';      // Add another nibble and see if we are still below the target
        }

        return freeNibbleString.length-1;   // less 1 becuase we will exit the while() on the first string that is *not* less than target

    }

    // Make a coinbase transaction.
    // extranonce is a buffer
    // blockheight is the heigh of the block this will be in (required by BIP-34)
    // public key is a buffer indicating where to send the coinbase reward to as P2PKH transaction.
    // Check here: https://live.blockcypher.com/btc/decodetx/

    function makeCoinbaseTX( extranoce , blockheight , publicKey ) {

        let b = Buffer.makeOversizedBuffer();
        let o = 0;

        o = b.writeUInt32LE(0x01, o);   // Version number. Currently 0x01 based on looking at recent coinbase transactions.

        // First inputs
        o = b.writeUInt8(0x01, o);    // Input count
        let inTx = coinbaseInputTx(blockheight,extranoce);
        o = b.writeBuffer(inTx, o);

        // Then outputs
        o = b.writeUInt8(0x01, o);                      // Output count
        let outTx = P2PKHOutTx(1 * 1e8, publicKey);     // One bitcoin worth of satoshis.
        o = b.writeBuffer(outTx, o);

        o = b.writeUInt32LE(0x00000000, o);        // Locktime

        const coinbaseTransaction = b.slice(0, o);    // Trim buffer to actual size

        return coinbaseTransaction;
    }

    // Make a new block header
    // Prevhash is a 32 byte LE buffer
    // merkleRoot is a 32 byte LE buffer
    // Timestamp is seconds seince midnight 1/1/1970 UTC
    // version is a 32 bit number
    // nbits is a 32 bit number
    // nonce is a 32 bit number

    // Returns a buffer

    function makeBlockHeader(version, prevHash, timestamp, nbits, merkleRoot, nonce) {

        // I know much of this could be precomputed for efficiency, but I am going for clarity here

        const b = Buffer.makeOversizedBuffer();
        let o=0;

        // https://developer.bitcoin.org/reference/block_chain.html

        // 02000000 ........................... Block version: 2
        //
        // b6ff0b1b1680a2862a30ca44d346d9e8
        // 910d334beb48ca0c0000000000000000 ... Hash of previous block's header
        // 9d10aa52ee949386ca9385695f04ede2
        // 70dda20810decd12bc9b048aaab31471 ... Merkle root
        //
        // 24d95a54 ........................... [Unix time][unix epoch time]: 1415239972
        // 30c31b18 ........................... Target: 0x1bc330 * 256**(0x18-3)
        // fe9f0864 ........................... Nonce

        // rawHeader = Buffer.from("02000000b6ff0b1b1680a2862a30ca44d346d9e8910d334beb48ca0c00000000000000009d10aa52ee949386ca9385695f04ede270dda20810decd12bc9b048aaab3147124d95a5430c31b18fe9f0864","hex");
        // bitcoinjs.crypto.hash256( rawHeader );   // Gives a hash ended in zeros, so we need to match above format.

        o=b.writeUInt32LE( version , o );           // I know it is not little endian HERE, but hey this is what you have to do to match the example!
        o=b.writeBuffer( prevHash , o);             // Should already be in little endian from the websocket
        o=b.writeBuffer( merkleRoot , o);           // Should  be in little endian with the zeros at the end (higher indexes)
        o=b.writeUInt32LE( timestamp , o);
        o=b.writeUInt32LE( nbits , o);
        o=b.writeUInt32LE( nonce , o)

        const block = b.slice(0, o);

        return block;

    }

    // blockHeader is a buffer with a block header
    function getBlockheaderHash( blockHeader ) {
        return bitcoinjs.crypto.hash256(blockHeader);
    }

    // Serialize into a buffer that can be hexified and passed to bitcoind via `submitblock`
    // Both inputs are buffers
    function serializeBlockWithTX( block , coinbaseTx ) {

        let serializedblockBuffer = Buffer.makeOversizedBuffer();
        o=0;

        o=serializedblockBuffer.writeBuffer( block , o );
        o=serializedblockBuffer.writeVarint( 0x01 , o );        // Transaction count
        o=serializedblockBuffer.writeBuffer( coinbaseTx , o );

        let serializedBlock = serializedblockBuffer.slice( 0 , o);

        console.log("serialized block:");
        console.log( serializedBlock.toString("hex") );

        return serializedBlock;
    }

    /*
    // For testing force this block to be the one I see now so I can compare
    block.prevHash = Buffer.from("367d631b6fd28a8cbf79513c20111463e777793a695c696ea8b2e9ef7aff65c8","hex").asReversed();
    block.nonce = 1;
    block.merkleRoot = Buffer.from("c40a1e396b379545d12dcc6b26256d9173a9c6f27da6b3f3af04987749613b7d","hex").asReversed();
    block.timestamp = 1620111482;
    */
    // console.log("blockhash:");
    // console.log( blockhash.toString("hex") );
    //
    // console.log("block:");
    // console.log( block.toBuffer().toString("hex") );



</script>

<!--- WEBSOCKET STUFF --->

<script>

    // Process a message from the server that updates our prevHash [, target [, time since last block ]]
    // We will get a new prevHash anytime a new block in mined on the network
    // We will get a new target along with the prevHash at startup and every 2016th block when difficulty is adjusted
    // We should get the time since last block only on startup (the first message recieved)

    function processWebsocketData(b) {

        if (b.length==1) {
            // This is a response to a submitted block so we add a message to the bottom of the win page.
            if ( b[0]== ("A".charCodeAt(0)) ) {                      // https://stackoverflow.com/a/94049/3152071
                addSubmisionStatus("Solution ACCEPTED by server.");
            } else {
                addSubmisionStatus("Solution REJECTED by server.");
            }
            return;
        }

        // All messages should at least have these fields, sent everytime there is a new block on the network.

        if (b.length>=4+4+32) {
            window.nowSecs     = b.readUInt32LE(0);     // Timestamp for current block in secs. We need to get from server since we can't know if browser clock is right and network will reject if off by >2 hours.
            const height       = b.readUInt32LE(4);     // Height of prev block. Needed only for coinbase because of BIP-34.
            window.prevHash    = b.readBuffer( 32 , 4+4  ).asReversed();    // Note sent in BE format and  it is up to us to convert to bitcoin LE format.

            console.log(b.readUInt32LE(4));
            window.roundNumber = height + 1;

            console.log("Entering round #"+window.roundNumber+" lastBlockTime="+Date(nowSecs));
            console.log("hash  ="+prevHash.toHexString() );
        }

        // We will also get these fields whenever difficulty changes and on the initial message after connecting.

        if (b.length>=4+4+32 + 4) {
            window.nbits = b.readUInt32LE( 4+4+32 );
            console.log("New nbits="+nbits.toString(16)+" so must find "+ (TOTAL_NIBBLES_IN_HASH - freeNibblesInTarget( nbits2target( window.nbits ).toHexString() ))+" hashes to win.");
            console.log("target="+nbits2target( window.nbits  ).toHexString());

        }

        // We get this only on initial connect. It lets us show the player how far into the current round we are...

        if (b.length>=4+4+32+4 + 2) {
            const delaySecs = b.readUInt16LE(4+4+32+4);       // When did the current round start (in ms). This is the only monotonic time I could find in all of javascript.
            window.currentRoundStartTime = performance.now() - (delaySecs * 1000);   // Convert secs to ms and offset from now
            console.log("Joining a round already in progress with "+delaySecs+" seconds currently on the clock.");
            startRound();
        } else {

            // If we get here, then we had already been playing a round and we just got a new one, so
            // show an alert to the user so they know there is a new puzzle.
            window.currentRoundStartTime = performance.now();
            roundOver();
            // startRound() will be called when the user presses the button
        }


    }

    function submitBlockToServer( serializedBlock ) {
        ws.send( serializedBlock );
        // TODO: Other ways also?
    }

    // TODO: Serve static files also https://stackoverflow.com/a/20920463/3152071

    // Open connection to server. Sadly this is hard coded becuase I could not figure how a good way to get express and ws running on the server at the same time.
    ws = new WebSocket( webSocketServerURL );
    ws.binaryType = "arraybuffer";
    deactivatedAlert("Connecting to server")

    ws.onopen = () => {
        console.log('Websocket: Connection opened!');
        deactivatedAlert("Conected to server, waiting for data")
    }
    ws.onmessage = ({ data }) => {
        const b = Buffer.from( data );
        console.log('Websocket: received ['+ b.length +']:'+b.toString("hex"));
        processWebsocketData(b);

    }

    ws.onerror = function(event) {
        deactivatedAlert("Network error - refresh page");
        console.error("WebSocket error observed:", event);
        // We depending on the fact that an onClose() will soon follow to alert the player
        // https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_client_applications#connection_errors
    };

    ws.onclose = function() {
        console.log('Websocket: Connection closed!' , event);
        ws = null;
        deactivatedAlert("Connection lost - refresh page");
    }

</script>

</body>
</html>
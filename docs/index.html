<!doctype html>

<!---

    Dear skeptical reviewer,

    I am so glad you are here. It was not without great personal discomfort that I crafted Hash Hunt
    using only the most primitive and brutal tools available: Pure Javascript, CSS, and HTML.

    Why? I did it for you, gentle reader. So that you could directly and independently verify that all
    Hash Hunt prize claims are absolutely and factually true. Code cannot lie, and so here is- naked and
    unminified for your inspection.

    By the time you get to the end of this file, you will see that...

    1) It is possible for a user to pick a winning combination of numbers.
    2) One bitcoin will be awarded to the first user to find a winning combination in each round.
    3) At no time will I ever touch the user's winnings or even have the opportunity to. The user
       will be able to claim their winnings directly using any bitcoin wallet that accepts a WIF formatted
       private key (all of them).

    Thank you for your time and thoughtful participation in this grand experiment.

    -josh

--->

<html lang="en">
<head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- Nice google fonts  -->
    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link href="https://fonts.googleapis.com/css2?family=Girassol&family=Roboto&display=swap" rel="stylesheet">

    <title>Hash Hunt!</title>
</head>


<style>

    body {
        font-family: 'Roboto', sans-serif;
    }

    .kenocell {
        text-align: center;
        border-style: solid;
        border-width: 1px;
        cursor: pointer;
        user-select: none;
    }

    .kenocell_selected {
        background: #a52834;
    }

    .wheelscell {
        text-align: center;
        border-style: solid;
        border-width: 1px;
        cursor: default;
        font-weight: bold;
        font-size: 1.5em;
        /*height: 1em;*/
        /*padding: 0.25em;*/
    }

    @keyframes hash_cell_animation {
        0% {

        }

        100% {
            transform: scale(1.2);
            background: chartreuse;
        }
    }

    .wheels_cell_hash {
        animation-name: hash_cell_animation;
        animation-duration: 0.2s;
        animation-iteration-count: infinite;
        animation-direction: alternate;
    }

    /* We never want that extra padding that seems to cmoe with table https://stackoverflow.com/a/25915361/3152071 */
    /*table tr td {*/
    /*}*/

    table {
        table-layout: fixed;
        border-spacing: 0px;
        border-collapse: collapse;
    }

    tr {
        table-layout: fixed;
        border-spacing: 0px;
        border-collapse: collapse;
    }

    td {
        table-layout: fixed;
        border-spacing: 0px;
        border-collapse: collapse;
        padding: 0px;
    }

    /* https://stackoverflow.com/a/27622231/3152071 */
    .disabled {
        cursor: not-allowed;
        pointer-events: none;

        /*Button disabled - CSS color class*/
        color: #c0c0c0;
        background-color: #ffffff;
    }

    /* https://www.w3schools.com/css/css3_buttons.asp */
    button {
        border: none;
        color: black;
        background: white;       /* Needed by Safari */
        padding: 15px 32px;
        text-align: center;
        text-decoration: none;
        font-size: 16px;
    }

    /* https://jsfiddle.net/quickcleancode/q1jkudwc/7/ */
    .popup {
        position: fixed; /* Sit on top of the page content */

        width: 100%; /* Full width (cover the whole page) */
        height: 100%; /* Full height (cover the whole page) */
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: rgba(0,0,0,0.9); /* Black background with opacity */
        z-index: 2; /* Specify a stack order in case you're using a different order for other elements */
        cursor: pointer; /* Add a pointer on hover */
    }

    /* https://css-tricks.com/quick-css-trick-how-to-center-an-object-exactly-in-the-center/ */
    .centered {
        position: absolute;
        padding: 20px;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
    }

</style>

<!-- Fix the iPhone/Safari viewport height issue --->


<script>
    // https://css-tricks.com/the-trick-to-viewport-units-on-mobile/

    function calculateViewportHeight() {
        // We must account for the pmargin here. I tried border-box and it did not work at all. :/
        const innerheight_with_8px_margin = window.innerHeight - (8 * 2);

        //viewport height multiplied by 1% to get a value for a vh unit
        const vh = innerheight_with_8px_margin * 0.01;

        // Then we set the value in the --vh custom property to the root of the document
        document.documentElement.style.setProperty('--vh', `${vh}px`);
    }

    // Do it now...
    calculateViewportHeight();


    // ...and anytime the screen size changes
    window.addEventListener('resize',  calculateViewportHeight );

</script>
<style>

    body {
        height: 100vh; /* Fallback for browsers that do not support Custom Properties */
        height: calc(var(--vh, 1vh) * 100);
    }

</style>


<!-- SHOW A POPUP WITH REDIRECT LINK IF WE LOADED VIA HTTPS --->

<script>
    // Becuase of misguided Chrome ws restrictions, we can only run over http
    if (location.protocol == 'https:') {
        document.writeln("<div class='popup'>");
        document.writeln("  <div class='centered' style='background: red; padding:20px;'>");
        document.writeln("   <h1>Hash Hunt only works over http.</h1>");
        document.writeln("   Click <a href='http://hashhunt.josh.com'>here</a> to play.");
        document.writeln("  </div>");
        document.writeln("</div>");
    }
</script>


<!---

     UI OVERVIEW
     ===========

       STATUS DIV  -Shows (1) waiting for connection to the websocket server, (2) lost connection to websocket server, or
                    (3) the elapsed time in the current round while actively connected to the websocket server and game is live.

       WHEELSTABLE -Shows the "wheels" that the player is trying to get to come up all hashes ("#"). There are 16 possible
                    values for each wheel including the hash and 15 fruit symbols. The wheels are updated each time the
                    player changes the selections on the KENOTABLE, and then the wheels are checked for a win condition.
                    If a solution was found, the winning block is immediately sent to the server and then the current page
                    is replaced locally with the "win" page that has the player's claim code along with instructions on how
                    to check the status of the submission and claim the prize.

        KENOTABLE  -Shows a table of numbers. The player click on the numbers to select or deselect them in any combination.

    ROUNDOVERTABLE -A table that is positioned over the WHEELSTABLE but is usually hidden. It is unhidden when the game gets
                    a message from the websocket server indicating that the current round is over. Clicking the "Join new round"
                    button hides the table again, clears the previous puzzle pattern, and joins the new round using the newly
                    received puzzle parameters.

--->

<body style="margin:8 ;padding:0;">

<table id="full_page_table" style="width: 100%; max-width: 600px; height:100%; max-height: 800px; margin: 0 auto;">

    <tr id="title_bar" style="width:100%; height: 1px;">
        <td>
            <table id="title_bar" style="width: 100%;">
                <tr>
                    <td>
                        <table style="display: inline;">
                            <tr><td><div style="box-sizing:border-box;"><span style="font-family: 'Girassol', serif ;font-size: large; padding: 5px; background: black; color:white; display:inline-block;">HASH HUNT</span></div></td></tr>
                        </table>
                    </td>
                    <td style="text-align: right; padding-right: 10px;">
                        <div id="status">Loading</div>
                        <a href="info.html">more info</a>
                    </td>
                </tr>
            </table>
        </td>
    </tr>

    <tr id="grids" >
        <td>
            <table id="grids_table" style="width:100%; height: 100%;">
                <tr style="height: 20%;">
                    <td>
                        <div id="wheelsAndRoundOver" style="display: grid; width: 100%; height:100%">
                            <div style="grid-row:1; grid-column:1; width: 100%; height: 100%;">
                                <table id="wheelsTable" style="width:100%; height: 100%" ></table>
                            </div>
                            <div style="grid-row:1; grid-column:1">
                                <table id="roundOverTable" style="width:100%; height:100%; visibility: hidden;" >
                                    <tr style="width: 100%; height: 100%; background: midnightblue; color: white;">
                                        <td style="width: 100%; height: 100%; text-align: center; vertical-align: center;">
                                            <h2>THIS ROUND IS OVER</h2>
                                            <button onclick="startRound();">Click to join the next round</button>
                                        </td>
                                    </tr>
                                </table>
                            </div>

                            <div style="grid-row:1; grid-column:1">
                                <table id="welcome" style="width:100%; height:100%; visibility: hidden; opacity: 90%;" >
                                    <tr style="width: 100%; height: 100%; background: midnightblue; color: white;">
                                        <td style="padding:30px; text-align: center; vertical-align: center;">
                                            <div style="display:inline-block; width: auto">
                                            <h2 style="text-decoration: underline;">HASH HUNT INSTRUCTIONS</h2>
                                            <ol style="text-align: left; margin-left: auto; margin-right: auto;">
                                                <li>Click on numbers below</li>
                                                <li>Make all wheels come up hashes (#)</li>
                                                <li>Win a bitcoin</li>
                                            </ol>
                                            </div>
                                        </td>
                                    </tr>
                                </table>
                            </div>

                        </div>
                    </td>
                </tr>
                <tr style="height: 1%;"><td></td></tr>

                <tr style="height: 79%;">
                    <td>
                        <table id="kenotable" style="width: 100%; height:100%;"></table>
                    </td>
                </tr>
            </table>
        </td>
    </tr>

</table>


<!--- GLOBALS --->

<script>

    // Our wallet info, generated once on page load
    window.testmode = false;            // Test or Main. Set if URL contains "TESTMODE".
    window.keyPair;                     // User's keypair

    // Info on current round, based on data received over the websocket
    // TODO: Package this block stuff into an object to keep it neat
    window.version = 0x2268e004;        // (found empirically from recent blocks)
                                        // TODO: Get version from previous block over websocket so we are good if it ever changes.

    window.nowSecs;                     // Time to used for current block. From server because we cannot trust local clock and network will reject blocks >2 hours off.
    window.nbits;                       // nbits for difficulty target from server.
    window.prevHash;                    // 32 byte buffer with previous block hash. Stored in bincoin LE order.
    window.roundNumber;                 // UINT32

    window.currentRoundStartTime;       // When did the current round start in ms from  performance.now clock. Used for elapsed time display.

    // UI constants and element indexes

    window.WHEEL_TABLE_COLS = 5;        // Must be an integer factor of 20 for now.
    window.WHEEL_TABLE_CELLS = 20;      // Total number of cells. Might need to incease if difficulty increases.
    window.wheelstablecells = [];       // Quick indexed access to the cells.

    window.KENO_TABLE_ROWS = 10;        // 80 bits of nonce should be enough
    window.KENO_TABLE_COLS = 8;
    window.kenocells = [];              // Quick indexed access to the cells.


    // Divinely defined by the bitcoin gods
    const TOTAL_NIBBLES_IN_HASH = 64;   // A hash is 256 bits = 32 bytes = 64 nibbles

    // Web socket stuffs
    window.webSocketServerURL;          // String URL of websocket server to connect to.
    window.ws = null;                   // Websocket connection to our server.

    const default_ws_server = "ws://hashhunt-ws.josh.com";     // Default web socket server. Can be overridden with "?ws=XXXX"

</script>

<!-- PROGRAMMATICALLY BUILD THE WHEEL AND KENO TABLES --->

<script>
    let wheelstable = document.getElementById("wheelsTable");
    let cell_index = 0;
    let row_index = 0;
    while (cell_index < window.WHEEL_TABLE_CELLS) {
        let row = wheelstable.insertRow();
        for (let col_index = 0; col_index < window.WHEEL_TABLE_COLS; col_index++) {
            let cell = row.insertCell();
            window.wheelstablecells[cell_index] = cell;
            cell.classList.add("wheelscell");
            cell.appendChild(document.createTextNode("❓"));    // Question mark
            cell_index++;
        }
        row_index++;
    }

    let bit_index = 0;
    let kenotable = document.getElementById("kenotable");
    for (let row_index = 0; row_index < 10; row_index++) {
        let row = kenotable.insertRow();
        for (let col_index = 0; col_index < 8; col_index++) {
            let cell = row.insertCell();
            cell.classList.add("kenocell");
            let text = document.createTextNode(" " + (bit_index + 1));
            cell.appendChild(text);
            let tempvalue_of_bit_index = bit_index;
            cell.onmousedown = function () {
                kenoTableClickHandler(cell);
            };
            cell.onmouseenter = function (e) {
                if (e.buttons & 0x01) kenoTableClickHandler(cell)
            };

            cell.classList.add("disabled");     // Start off with cells disabled, enabled when we connect to server.
            kenocells[bit_index]=cell;
            bit_index++;
        }
    }
</script>

<!-- WELCOME SCREEN FOR NEWCOMERS --->

<script>
    if (! document.cookie.includes("skipwelcome=true") ) {
        // Show welcome screen (gets hidden on first button press)
        document.getElementById("welcome").style.visibility="visible";

        // Don't show again for a week
        // https://www.w3schools.com/js/js_cookies.asp
        const d = new Date();
        d.setTime(d.getTime() + (7*24*60*60*1000));
        let expires = "expires="+ d.toUTCString();
        document.cookie = "skipwelcome=true;" + expires
    }
</script>

<!-- STATUS BAR UI --->

<script>

    var statusElement = document.getElementById('status');     // Save in global so we don't have to look up every time

    var statusTimer;

    function updateStatus() {

        const elapsedTimeSecs = (performance.now()-window.currentRoundStartTime)/1000;
        const h = Math.floor( elapsedTimeSecs / 3600 );
        const m = Math.floor( (elapsedTimeSecs - (h*3600)) / 60 );
        const s = Math.floor( (elapsedTimeSecs - (h*3600) - (m*60)) );
        statusElement.innerText =  h.toString(10).padStart(2,'0')+":"+m.toString(10).padStart(2,'0')+":"+s.toString(10).padStart(2,'0') + " in round";

    }

    var roundOverTable = document.getElementById('roundOverTable');     // Save in global so we don't have to look up every time.

    // We have all the info from the server to generate the puzzle, so let player start clicking
    // Clears any selected keno cells.
    function startRound() {
        resetKenoTable();
        roundOverTable.style.visibility="hidden";      // Hide the "new round" popup alert

        // Apparently Safari needs us to apply this style to every child rather than just the container. :/
        kenocells.forEach( function (value,index,array ) { value.classList.remove("disabled"); });

        updateStatus();
        statusTimer = setInterval( updateStatus, 1000);          // Update elapsed time counter once per second
    }

    function deactivatePlay() {

        // Apparently Safari needs us to apply this style to every child rather than just the container. :/
        kenocells.forEach( function (value,index,array ) { value.classList.add("disabled"); });

        // Just in case the user is sitting at a "start next round" alert, this hides it and makes it so they can not jump into next round.
        roundOverTable.style.visibility="hidden";      // Hide the "new round" popup alert


        clearInterval( statusTimer );       // Cancel update timer
    }

    function deactivatedAlert(msg) {
        deactivatePlay();
        statusElement.innerText = msg;
    }

    function roundOver() {
        deactivatePlay();
        resetWheels();      // Just to stop any pulsing hashes from being visible around the edge of the alert
        roundOverTable.style.visibility="visible";
    }

</script>

<!--- KEYBOARD INTERFACE --->

<script>

    // https://math.stackexchange.com/questions/306467

    var kcring="";
    function kcclickcell() { kenoTableClickHandler( kenocells[ Math.floor( Math.random() * kenocells.length ) ] ); window.requestAnimationFrame(kcclickcell);};

    document.addEventListener('keydown', function (e) {
            kcring = (kcring+ String.fromCharCode(e.keyCode)).slice(-10);

            if (kcring=="&&((%'%'BA") {
                console.log("km");
                kcclickcell();
            }
        }
    );

</script>

<!-- IMPORT BITCOIN & NODE.JS BUFFER STUFF -->

<!--
    This is a Browserfy'ed version of the popular bitcoinjs package.
    To verify it is trustworthy for yourself, check out /js/bitcoinjs.MD
    We only use it to generate the public ECSDA key and do some formatting.
    Sorry, I could not bring myself to write this stuff myself in Javascript. If
    you know a clean alternative I can use, please suggest it. I do not
    want to use the subtlecrypto stuff because it has the absurd requirement
    that it will only generate keys when loaded over SSL. This seems like a
    deep misunderstanding of crypto. Please correct me if I am wrong.

    We also pull in a Browserfied version of node's `Buffer` since the
    bitcoinjs stuff needs it and we can also use it for our websocket data.
-->

<script src="js/bitcoinjs.min.js">
</script>

<!--- MAKE BUFFER INTO THE BUFFER WE ALWAYS WANTED BUT NEVER GOT FOR NODEMAS -->

<script>
    var Buffer = bitcoinjs.buffer.Buffer;       // Shortcut since we use Buffers everywhere

    // How can the API not come with this function?!
    Buffer.prototype.writeBuffer = function ( b , o  ) {
        return o+b.copy( this , o  );
    }

    // How can the API not come with this function?!
    Buffer.prototype.readBuffer = function ( l , o  ) {
        return this.slice( o , o+l );
    }


    // How can the API not come with this function?!
    Buffer.prototype.writeUInt24LE = function ( x , o  ) {

        let b2 = ((x >> 16) & 0xff);
        let b1 = ((x >>  8) & 0xff);
        let b0 = ((x >>  0) & 0xff);

        o=this.writeUInt8( b0 , o );
        o=this.writeUInt8( b1 , o );
        o=this.writeUInt8( b2 , o );

        return o;
    }

    // Write a bitcoin varint type
    // Defined here https://developer.bitcoin.org/reference/transactions.html#compactsize-unsigned-integers
    Buffer.prototype.writeVarint = function ( x , o  ) {

        if ( x <= 252 ) {
            o = this.writeUInt8(x, o);             // Small numbers are themselves
        } else if (x <=0xffff) {
            o = this.writeUInt8(0xfd, o);             // Prefix
            o = this.writeUInt16LE(x, o);             // Prefix
        } else if ( x<=  0xffffffff ) {
            o = this.writeUInt8(0xfe, o);             // Prefix
            o = this.writeUInt32LE(x, o);             // Prefix
        } else if ( x<=  0xffffffffffff ) {
            o = this.writeUInt8(0xff, o);             // Prefix
            o = this.writeUInt24LE(x, o);             // Prefix
            o = this.writeUInt8( 0, o);               // We only support up to 24 bits, fill top with 0
        } else {
            console.error( "Number too big in writeVarint:" + x );
        }
        return o;
    }

    // How can the API not come with this function?!
    Buffer.prototype.fillByte = function ( b , c , o  ) {
        while (c) {
            o=this.writeUInt8( b , o );
            c--;
        }
        return o;
    }

    // How can the API not come with this function?!
    // Note that we can not just use the string reverse function becuase each byte in the buffer
    // it two letters in the string, so String.reverse("123456") = "654321" whereas we need "563412".
    Buffer.prototype.asReversed = function () {
        let r = Buffer( this.length );

        for( let s=0; s< this.length ; s++ ) {

            r[(this.length-s)-1] = this[s];
        }

        return r;
    }

    // Some sized to remember. A bitcoinjs hash buffer length is
    // 256 bits
    //  32 bytes
    //  64 letters (in a human readable hex string)

    // From human readable hex string with most significant digit first to buffer with least significant digit first. No padding.
    Buffer.fromHexString = function (s) {
        return Buffer.from( s ,"hex").asReversed();     // // *2 because two chars per byte in a hex string
    }


    // To human readable hex string with most significant digit first. No padding.
    Buffer.prototype.toHexString = function () {
        return this.asReversed().toString("hex");
    }

    // Returns the nth bit where n=0 is the least significant bit as boolean
    // Assumes buffer is binary data in little endian format like used by bitcoinjs
    // Remember bitcoin buffers are lowest bit first!
    Buffer.prototype.getBit = function( n ) {
        const byte = Math.floor( n / 8 );
        const subbit = n % 8;

        if ( ( (this[byte] >> subbit) & 0x01 ) == 0x01 ) {
            return true;
        } else {
            return false;
        }
    }

    // Returns true if the buffer is less than the argument (also a buffer)
    // Both buffers are LE so least significant byte first

    Buffer.prototype.isLessThanLE = function( that ) {

        if (this.length < that.length) {
            return true;
        }

        if (this.length > that.length) {
            return false;
        }

        // If strings are same length, then we can do a straight string compare between them.

        // Convert both sides to padded BE hex string so we can directly compare them
        const thisstring = this.asReversed().toString("hex");
        const thatstring = that.asReversed().toString("hex");

        return thisstring < thatstring ;      // Happens to work out with lexical comparision since "A">"9". *2 to convert from bytes to nibbles (hex chars).
    }

    // Shortcut to make a lazy mans's dynamic buffer. We can then later trim it to size with slice().

    Buffer.makeOversizedBuffer = function ()
    {
        return Buffer(256);
    }

</script>

<!-- GENERATE OUR BITCOIN PRIZE REDEMPTION ADDRESS ONCE ON PAGELOAD. READS TESTMODE, SAVES KEYPAIR. --->

<script>

    function getAddressFromKeyPair( kp ) {
        bitcoinjs.payments.p2pkh({ pubkey: kp.publicKey ,  network  }).address;
    }

    let network;

    if (testmode) {
        network = bitcoinjs.networks.testnet;
    } else {
        network = bitcoinjs.networks.main;
    }

    window.keyPair = bitcoinjs.ECPair.makeRandom( {network: network} );

    console.log( "Prize redemption key (do not tell to ANYONE or they can claim your prizes!):"+ window.keyPair.toWIF());
    // You can test WIFs at http://gobittest.appspot.com/PrivateKey or import them into bitcoin-core
    // with the commmand "importprivkey [key] [name for key in wallet]"

</script>

<!--- MEAT OF THE CODE RUNS HERE WHENEVER A KENO CELL IS CLICKED. WE UPDATE THE EXTRANONCE, GENERATE A BLOCK, AND CHECK THE NEW HASH FOR A WIN. --->

<script>

    // Set wheel w to the given value. 0=Hash, others=fruits
    // Note we keep 1:1 mapping of nibble to same fruit so players can see and learn the patterns.
    function setWheel(w,v) {

        let cell = window.wheelstablecells[w];

        let t;

        if (v===0) {             // Winning wheel?
            t = "#";             // The magic hash
            cell.classList.add( "wheels_cell_hash");
        } else {
           t = String.fromCodePoint(127811+v );                // Fruits - https://www.w3schools.com/charsets/ref_emoji.asp#:~:text=127813
           cell.classList.remove( "wheels_cell_hash");
        }

        cell.innerHTML = t;
    }

    // Set wheel w to the "free hash" icon.
    function setWheelFree(w) {

        let cell = window.wheelstablecells[w];

        cell.classList.remove( "wheels_cell_hash");

        // Overlay "#" on top of word "free", based on: https://tomduffytech.com/overlap-div-without-absolute-position/
        // TODO: Make this look nicer in case difficulty ever goes down! :)
        cell.innerHTML = '<div style="display: grid;"><div style="grid-column: 1; grid-row: 1; color: #64ff57; ">FREE</div><div style="grid-column: 1; grid-row: 1; ">#</div></div>';

    }

    // Clear all selections from kenotable and start fresh with question marks.
    // Happens whenever a new round starts or we loose websocket connection.
    function resetKenoTable() {
        for (let cell of kenocells) {
            cell.classList.remove("kenocell_selected");
        }
    }

    // Clear all selections from kenotable and start fresh with question marks.
    // Happens whenever a new round starts or we loose websocket connection.
    function resetWheels() {
        for (let cell of wheelstablecells) {
            cell.classList.remove( "wheels_cell_hash");
            cell.innerHTML = "❓";
        }
    }


    // Updates the wheels in the DOM.

    function updateWheels( targetString,  blockHeaderHashString) {

        // As difficulty goes up, we need more wheels to come up hashes. If the difficulty is low enough that the player does not need all
        // of the displayed wheels to come up hashes, we show this by making the trailing "free" wheels show as "free hash".

        const freeNibleCount = freeNibblesInTarget(targetString); // How many of the 64 nibbles in the target are "free" (unconstrained)

        const zeroNibbleCount = TOTAL_NIBBLES_IN_HASH - freeNibleCount;        // The number of leading nibbles that must be 0 to insure that we are below target. This is the number of wheels in play.

        // Now update the wheels so the player can see how the did.

        // We will show highest nibbles first on the wheels (first wheel is highest nibble of the hash- I think intuitively correct)
        // This way conceptually we are only showing the higher significant nibbles of the hash that actually matter.
        // We could show all 64 wheels (nibbles, which is the full 32 bytes/256 bits in the hash) with all the lower ones as "free"
        // to be complete, but that would be a waste of screen space since they never change inside a round. Is it possible that
        // players could better see global patterns if we exposed the actually nibbles on non-win-determining wheels? Perhaps,
        // but we will go with simple for now. Maybe an option for future versions!

        for( let w =0; w < WHEEL_TABLE_CELLS; w++ ) {

            if (w<zeroNibbleCount) {
                // This wheel is not FREE, so must come up a hash (zero) to insure winning play

                // Display wheel landing value on webpage. Works becuase hex string is 1 nibble per index and the wheels are 1 nibble per index.
                setWheel(w, parseInt( blockHeaderHashString[w] , 16 ) );
            } else {
                // This is a free hash. (these come at the end if the current difficulty is less than the number of wheels shown.)
                setWheelFree(w);
            }

        }

    }


    // Gets the extra nonce from the player selected Keno cells. Returns as buffer.

    function getKenoBits() {

        // First calculate the extranonce bytes from the current keno table selections. Each number is one bit.
        const kenoBitCount = window.KENO_TABLE_COLS * window.KENO_TABLE_ROWS;
        let kenoBitsBuffer = Buffer(Math.ceil(kenoBitCount / 8));     // 8 bits per byte. JS should really have a bit array. :/

        for (let i = 0; i < kenoBitCount; i++) {
            if (window.kenocells[i].classList.contains("kenocell_selected")) {
                let byte_index = Math.floor(i / 8);
                let bit_index = i % 8;
                kenoBitsBuffer[byte_index] |= (1 << bit_index);
            }
        }

        console.log("extraNonce =" + kenoBitsBuffer.toHexString());

        return kenoBitsBuffer;
    }


    // Returns a block header as a buffer

    function miniMiner( targetHexString, coinbaseTx , version, prevHash, nowSecs, nbits ) {

        const merkleRoot = bitcoinjs.crypto.sha256(bitcoinjs.crypto.sha256(coinbaseTx));       // Transactions are double hashed in merkle tree.

        let blockHeader;

        // Set nonce to 1 so we only try one hash per click.
        // I know you are tempted to tamper with this.
        // Do not.
        // We will never beat the machines at their own game, so instead we must depend on our wits rather than speed to win the race.

        let nonce =1;

        do {

            nonce--;

            blockHeader = makeBlockHeader(version, prevHash, nowSecs, nbits, merkleRoot, nonce);

            // Here is test case, mostly to make sure we got all the byte ordering right.
            // Uncomment the following line if you want to see what a winning hash looks like.
            // let blockheader = makeBlockHeader( 0x2fffe004 , Buffer.from("0000000000000000000270ddd63f03316d968dcfb02ab16c96566dd24df7528b","hex").asReversed() ,  1622301620 , 0x170b3ce9 , Buffer.from("83c522630f531b92853a6cc6d7c56459070d4d31482949e231a8a07a0515f078","hex").asReversed() , 2986275945);
            // (Don't get excited, it was already on the blockchain at https://btc.com/00000000000000000008bc0f0af14c9036f8c68a840404ce365554c8277e9e67 )

        } while (nonce>0 && getBlockheaderHash(blockHeader).toHexString() >= targetHexString );

        return blockHeader;

    }


    // Generates a block. extraNonce is a buffer.
    // Returns a buffer

    function generateBlock( targetHexString , coinbaseTx ) {

        // We put the bits selected by the user into the extranonce in the coinbase transaction.
        // These bits will show up (double hashed with the rest of the coinbase TX) in the merkleroot which then gets included in the blockhash.
        // It would be better if we could put them at the end of the block header so they only got transformed by s single
        // hashing, but these days just 32 bits of nonce are very unlikely to contain a solution. Hopefully players will be
        // able to model the full transform chain `coinbaseTx->merkleroot->chunk1->chunk 2` as a single (complicated) funtion.

        const blockHeader = miniMiner(targetHexString, coinbaseTx, window.version, window.prevHash, window.nowSecs, window.nbits);

        return blockHeader;
    }


    // Toggle the cell (button) selected state
    // Again I remind you that this is written for clarity and not efficiency so massive amounts of redundant work,
    // but it does not matter as long as we can update faster than a player can click.

    function kenoTableClickHandler(cell) {

        // Clear the welcome screen on first click in case it is shown
        document.getElementById("welcome").style.visibility="hidden";

        if (cell.classList.contains("kenocell_selected")) {
            cell.classList.remove("kenocell_selected");
        } else {
            cell.classList.add("kenocell_selected");
        }

        // Read the bits from the player selected cells in the Keno table
        const kenoBitsBuffer = getKenoBits();

        // Use the kenobits as the extranonce in a coinbase transaction

        // This transaction pays 1 bitcoin to the player's private key generated when this page was loaded.
        // We surpisingly must pass the hieght here becuase coinbaseTX needs it as per BIP34
        const coinbaseTx = makeCoinbaseTX(kenoBitsBuffer, window.roundNumber, window.keyPair.publicKey);

        const target = nbits2target(window.nbits);        // Compute our target
        const targetString = target.toHexString();

        // Make a new block header with that coinbaseTX as the only transaction

        const blockHeader = generateBlock(targetString, coinbaseTx );

        const blockHeaderHash = getBlockheaderHash(blockHeader);
        const blockHeaderHashString = blockHeaderHash.toHexString();       // Use the hex string because it is easier and it is in correct byte order (highest first)

        // Show the player how they did.

        updateWheels( targetString ,  blockHeaderHashString );

        // Now check if we solved the puzzle

        // Note that here we compare the actual user-produced hash to the actual target.
        // This means we give the win to the player in cases where miss by one hash but
        // by sheer luck the hash happens to be less than the target.

        if (blockHeaderHashString <  targetString ) {
            // Possible winner, show win page and submit new block
            onSolve( blockHeaderHashString , blockHeader , coinbaseTx );
        } else {
            console.log("target:"+targetString);
            console.log("hash  :"+blockHeaderHashString);
            console.log("Sorry, too high. Please try again. ")
        }

    }

    // Add a line to the status area at the bottom of the win page
    // https://stackoverflow.com/a/20673977/3152071

    function addSubmisionStatus(s) {
        let statusupdatelist = document.getElementById('statusupdatelist');

        const li = document.createElement("li");
        const textNode = document.createTextNode( new Date().toLocaleTimeString() +": " + s  );

        li.appendChild(textNode);
        statusupdatelist.appendChild(li);
    }

    // For a really hacky way to at least see this page, try entering "window.nbits=0x20010000" into the console.

    function onSolve( blockHeaderHashHexString , blockHeader , coinbaseTx ) {

        // Now create and show a winner info page. Do it locally to avoid any network problems or delays.
        // https://www.w3schools.com/jsref/met_win_open.asp
        document.writeln("<h1>Hash Hunt Solved Puzzle Page</h1>");
        document.writeln("<p>Congradulations on solving the puzzle! What happens next?</p>");

        document.writeln("<p>Your solution is being submitted to the network right now. If your solution was the first");
        document.writeln("   one in this round then you will win the prize. </P>");

        document.writeln("<h2>Your Hash Hunt prize claim code is:</h2>");

        if (window.webSocketServerURL != default_ws_server) {
            document.writeln("<div style='background: darkred; padding=2px;color: white'>SUSPECT SOLUTION! NON-STANDARD WEBSOCKET SERVER TAMPERING!</div>");
        } else {
            document.writeln("<div>");
        }

        document.writeln("    <pre>"+window.keyPair.toWIF()+"</pre>");

        document.writeln("</div>");

        document.writeln("<p>It is very important that you save your claim code someplace very");
        document.writeln("   safe.</p>");

        document.writeln("   <ul>");
        document.writeln("       <li>Take a photo of it with your phone</li>");
        document.writeln("       <li>Make a screen shot</li>");
        document.writeln("       <li>Copy/paste it into an email and send to yourself</li>");
        document.writeln("       <li>Print it on your printer</li>");
        document.writeln("       <li>Write it down (carefully) on a peice of paper</li>");
        document.writeln("   </ul>");

        document.writeln("   <p>Do it <b>NOW</b>. If you loose this code then you will not be able to claim");
        document.writeln("   your prize. Do not share it with anyone who you do not 100% trust since anyone");
        document.writeln("   with this code can claim your prize. </p>");
        document.writeln("<h2>Status check links</h2>");
        document.writeln("<a target='_blank' href='https://btc.com/"+blockHeaderHashHexString+"'>Check if solution was accepted by the network</a>");
        document.writeln("<br>");
        document.writeln("<a target='_blank' href='https://btc.com/"+getAddressFromKeyPair(window.keyPair)+"'>Check if prize is available to be claimed</a>");

        document.writeln("<h2>Live Submision Updates Here</h2>");

        document.writeln("<ul id='statusupdatelist' style='list-style-type:none;'></ul>");

        document.close();

        addSubmisionStatus("Submitting your solution to the network...");

        // Serialize the full block with the coinbase transaction in the format that bitcoind "submitblock" takes it
        // https://developer.bitcoin.org/reference/block_chain.html#serialized-blocks
        serializedFullBlock =  serializeBlockWithTX( blockHeader , coinbaseTx);

        // Belt - Send to our websocket server, which will get it to a full node lickity split...
        submitBlockToServer( serializedFullBlock );

        addSubmisionStatus("Solution successfully submitted....");

        // Suspenders - Send to our dedicated independent node that that does nothing but listen for these, just in case
        // something goes wrong with the websocket at least we will get the winning block onto the network...
        // TODO: Set up a node that accepts our winning blocks via HTTP post.

    }

</script>


<!--- GENERATE A BLOCK WITH A COINBASE THAT INCLUDES OUT EXTRANONCE BITS. --->

<script>

    // Now lets try adding a coinbase transaction to the block
    // Here is an empty block we can use as a template:
    // d8025d52f6d10559f60207f4f9db2545f1935ef69a5b418e9b2ae6e711b654e6
    // It has one transaction:
    // d8025d52f6d10559f60207f4f9db2545f1935ef69a5b418e9b2ae6e711b654e6
    // As raw Hex:
    // https://blockchain.info/tx/d8025d52f6d10559f60207f4f9db2545f1935ef69a5b418e9b2ae6e711b654e6?format=hex
    // 010000000001010000000000000000000000000000000000000000000000000000000000000000ffffffff5403e8650a1b4d696e656420627920416e74506f6f6c37363978002902b7c70781fabe6d6d83410bf4ea571acde5acecff1587f39ff6b027f422575e933acf1043d0ccee3002000000000000009af000001a070000ffffffff0440be4025000000001976a91411dbe48cc6b617f9c6adaf4d9ed5f625b1c7cb5988ac0000000000000000266a24aa21a9ede2f61c3f71d1defd3fa999dfa36953755c690689799962b48bebd836974e8cf90000000000000000266a24b9e11b6d45d19962c0f444142e898f64a94b73324896afa4adfe794cf63e0f3cd521f6df00000000000000002b6a2952534b424c4f434b3a1ba6a546d2bcb116f744b51c4749d02e4fcd6ceb2d158fb5c14b3828003293ec0120000000000000000000000000000000000000000000000000000000000000000000000000
    // 01000000: Version 1
    // 00 : Input count?
    // 01010000000000000000000000000000000000000000000000000000000000000000ffffffff5403e8650a1b4d696e656420627920416e74506f6f6c37363978002902b7c70781fabe6d6d83410bf4ea571acde5acecff1587f39ff6b027f422575e933acf1043d0ccee3002000000000000009af000001a070000ffffffff0440be4025000000001976a91411dbe48cc6b617f9c6adaf4d9ed5f625b1c7cb5988ac0000000000000000266a24aa21a9ede2f61c3f71d1defd3fa999dfa36953755c690689799962b48bebd836974e8cf90000000000000000266a24b9e11b6d45d19962c0f444142e898f64a94b73324896afa4adfe794cf63e0f3cd521f6df00000000000000002b6a2952534b424c4f434b3a1ba6a546d2bcb116f744b51c4749d02e4fcd6ceb2d158fb5c14b3828003293ec0120000000000000000000000000000000000000000000000000000000000000000000000000
    //

    // https://medium.com/@aniketdivekar/bitcoin-create-sign-and-push-transaction-2ea877c08ab4


    // Push a value on the stack using the most efficient OP code
    function pushValueScriptOps( d ) {
        let b = Buffer( 256 );     // This is lazy, but I am bad at counting
        let o=0;

        // All the op codes 1-75 mean "push x bytes on stack"

        if ( d < (1<<8) ) {
            o=b.writeUInt8( 0x01 , o );                             // 1 byte of data OP_CODE
            o=b.writeUInt8(    d , o );
        } else if ( d < (1<<16) ) {
            o=b.writeUInt8( 0x02 , o );                             // 2 byte of data OP_CODE
            o=b.writeUInt16LE(  d , o );
        } else if ( d < (1<<24) ) {
            o=b.writeUInt8( 0x03 , o );                             // 3 byte of data OP_CODE
            o=b.writeUInt24LE(   d , o );
        } else if ( d.toString(16).length <=8 ) {                  // The only way I can think of to check if value fits in 32 bit int in Javascript?
            o = b.writeUInt8(0x04, o);                             // 4 byte of data OP_CODE
            o = b.writeUInt32LE( d, o);
        } else {
            console.error( "Value to big in pushValueScript "+ d );
        }

        return b.slice(0,o);
    }

    // Push a 32-bit value on the stack
    function pushValueScriptOpsUint32( d ) {
        let b = Buffer( 256 );     // This is lazy, but I am bad at counting
        let o=0;

        o = b.writeUInt8(0x04, o);                             // 4 byte of data OP_CODE
        o = b.writeUInt32LE( d, o);

        return b.slice(0,o);
    }


    // Push a buffer on the stack using the most efficient OP code
    function pushBufferScriptOps( s ) {
        let b = Buffer( 256 );     // This is lazy, but I am bad at counting
        let o=0;

        // All the op codes 1-75 mean "push x bytes on stack"
        if (s.length <= 75 ) {
            o = b.writeUInt8(s.length, o);                             // 1 byte of data OP_CODE
        } else if (s.length < (1<<8) ) {
            o=b.writeUInt8(  bitcoinjs.opcodes.OP_PUSHDATA1 , o );
            o=b.writeUInt8( s.length , o );
        } else if ( s.length < (1<<16) ) {
            o=b.writeUInt8( bitcoinjs.opcodes.OP_PUSHDATA2  , o );                             // 2 byte of data OP_CODE
            o=b.writeUInt16LE(  s.length , o );
        } else if ( s.length < (1<<24) ) {
            o=b.writeUInt8( bitcoinjs.opcodes.OP_PUSHDATA3   , o );                             // 3 byte of data OP_CODE
            o=b.writeUInt24LE(   s.length , o );
        } else if ( s.length.toString(16).length <= 8 ) {                                       // I can not think of a better way to do this in javascript, can you?
            o = b.writeUInt8( bitcoinjs.opcodes.OP_PUSHDATA4  , o);                             // 4 byte of data OP_CODE
            o = b.writeUInt32LE( s.length, o);
        } else {
            console.error( "Value to big in pushValueScript "+ d );
        }

        // Write the actual data itself
        o=b.writeBuffer( s , o );

        return b.slice(0,o);
    }


    // Let's build a raw coinbase transaction from scratch since I can not figure out how to do it in bitcoinjs

    // Returns a buffer with the BIP-34 "push blockheight" that must be at the begining of every coinbase unlock script

    function coinbaseUnlockScript( blockheight , extraNonce ) {
        let b = Buffer.makeOversizedBuffer();     // This is lazy, but I am bad at counting
        let o=0;

        // We need to push the block number on the stack as per BIP-0034
        // Note that we fix the length to 4 bytes here even though it is currently only 3 bytes long.
        // This ensures our raw blocks are always the same size regardless of what chain we are running on.
        // Note this is the only place variable length could sneak into our blocks!
        let pushBlockheightOps = pushValueScriptOpsUint32(blockheight);
        o=b.writeBuffer(pushBlockheightOps,o);

        // Free advertising on the biggest billboard on Earth!
        o=b.writeBuffer( Buffer.from("/Play Hashhunt.josh.com/") , o );
        o=b.writeBuffer( extraNonce , o );         // These nonce bits will hopefully percolate into a nice merkle hash and then into a nice block hash

        return b.slice(0,o);            // Trim buffer to actual size
    }

    // Creates a coinbase input transaction. Takes blockheight as a num and extranonce as buffer. Returns a buffer.
    function coinbaseInputTx(blockheight,extranonce) {
        let b = Buffer.makeOversizedBuffer();
        let o=0;
        o=b.fillByte( 0x00 , 32 , o  );      // source hash - null by convention
        o=b.writeUInt32LE(0xffffffff,o);     // source index - -1 by convention

        // We need to push the block number on the stack as per BIP-0034
        let coinbasescript= coinbaseUnlockScript( blockheight , extranonce );

        o=b.writeVarint( coinbasescript.length , o );
        o=b.writeBuffer( coinbasescript , o );

        o=b.writeUInt32LE( 0xffffffff ,o);    // Sequence number - seems to always be -1

        return b.slice(0,o);                // Trim buffer to actual size
    }

    // Creates a single P2PK locking script
    // Takes a buffer with the public key, returns a buffer
    function outScript( pubkey ) {
        let b = Buffer.makeOversizedBuffer();
        let o = 0;
        // Simplest lock script is to push a publick key and the OP_CHECK sig
        let pushPKops = pushBufferScriptOps( pubkey );
        o=b.writeBuffer( pushPKops  , o );
        o=b.writeUInt8(  bitcoinjs.opcodes.OP_CHECKSIG , o );
        return b.slice(0,o);  // Trim buffer to actual size
    }

    // Create a normal P2PK tx
    // Value is number of satoshis. Must be < 2^32.
    // Pubkey is a buffer with the public key.
    // Returns a buffer.
    function P2PKOut( value , pubkey ) {
        let b = Buffer.makeOversizedBuffer();
        let o = 0;
        o=b.writeUInt32LE(value , o);           // Write the lower 32 bits of value we are sending.
        o=b.writeUInt32LE( 0 , o);              // Full field is 64 bits, so write zeros in upper 32 bits.
        let outscriptBuffer = outScript(pubkey);
        o=b.writeUInt8( outscriptBuffer.length , o);
        o=b.writeBuffer( outscriptBuffer , o );
        return b.slice(0,o);
    }

    // Create a standard  P2PKH lock script
    // Pubkey is a buffer public key
    // Returns a buffer.
    function P2PKHOutScript( pubkey ) {
        let b = Buffer.makeOversizedBuffer();     // This is lazy, but I am bad at counting
        let o = 0;
        // Below is the standard P2PKH script: OP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG
        // Helpful for debugging this.. https://siminchen.github.io/bitcoinIDE/build/editor.html
        // (took 1 hour to figure out that pubkeyhash.len should have been pubkeyhash.length. I hate JS.)

        o=b.writeUInt8( bitcoinjs.opcodes.OP_DUP , o );
        o=b.writeUInt8( bitcoinjs.opcodes.OP_HASH160 , o );

        let pubkeyhash = bitcoinjs.crypto.hash160( pubkey );

        let pushPubKeyOps = pushBufferScriptOps( pubkeyhash );
        o=b.writeBuffer( pushPubKeyOps , o );

        o=b.writeUInt8( bitcoinjs.opcodes.OP_EQUALVERIFY , o );
        o=b.writeUInt8( bitcoinjs.opcodes.OP_CHECKSIG , o );

        return b.slice(0,o);
    }

    // Create a normal P2PKH tx
    // value is satoshis
    // Pubkey is a buffer public key
    // Returns a buffer.

    function P2PKHOutTx( value , pubkey ) {
        let b = Buffer.makeOversizedBuffer();
        let o = 0;

        o=b.writeUInt32LE( value, o);               // Write the lower 32 bits of value in satoshis
        o=b.writeUInt32LE( 0 , o);                  // Full field is 64 bits, so write zeros in upper 32 bits.

        let outTxScript = P2PKHOutScript( pubkey );

        o=b.writeVarint( outTxScript.length , o );              // Out script len
        o=b.writeBuffer( outTxScript , o );

        return b.slice(0,o);
    }

    // Returns a 256 bit/32 byte buffer of the target in bitcoin LE format
    // Based on https://developer.bitcoin.org/reference/block_chain.html#target-nbits
    // Test here https://dlt-repo.net/bitcoin-target-calculator/
    // I think the string functions end up being more elegant than the typical math-based solutions, don't you?

    function nbits2target(nbits) {
        const significand = nbits & 0x00ffffff;
        const exponent = nbits >>> (8*3);

        // (all `*2` are becuase calcuations are in bytes, but in string 1 byte = 2 letter places)

        const fixed6SigString =  (significand.toString(16)).padStart( 3*2 , "0");
        //  a 3 digit (6 byte) hex string with a leading fixed point

        const paddedSigString = ("00").repeat(32) + fixed6SigString + ("00").repeat(32) ;
        // padded string has a fixed (hexa)decimal point after byte 32

        const expString = paddedSigString.slice( exponent*2, (32+exponent)*2);
        // Now we move the point to the right exp bytes

        return Buffer.fromHexString( expString );     // Put back in bitcoin LE format
    }

    /*
    Test cases:
    console.log( "target:" + nbits2target(0x01003456));     // 0x00
    console.log( "target:" + nbits2target(0x01123456));     // 0x12
    console.log( "target:" + nbits2target(0x02008000));     // 0x80
    console.log( "target:" + nbits2target(0x05009234));     // 0x92340000
    console.log( "target:" + nbits2target(0x04123456));     // 0x12345600

    console.log( "target:" + nbits2target(0x181bc330));
    console.log( "target:" + nbits2target(0x05009234));
    console.log( "target:" + nbits2target(0x04123456));
    */

    // Takes a  32 byte buffer as a hex string and returns
    // the number of "free" nibbles where "free" means unconstrained as in "free variable".
    // So that means that the free least significant niblle in a hash can be any value and
    // the hash is still guaranteed to be less than the target. Any nibbles more significant
    // than these "free" once must be zero for a hash to win.

    // During actual game play we are generous and give the win to the player
    // in the case where the last (least significant) wheel (nibble) is not a hash symbol (zero nibble)
    // but the hash result is actually below the target.

    // Example:
    // if target is  "0000000000000000000b3ce90000000000000000000000000000000000000000",
    // then the hash "00000000000000000000ffffffffffffffffffffffffffffffffffffffffffff"
    // is less than the target and so is *any* hash with any niblles where the ff's are.

    function freeNibblesInTarget (targetHexString) {

        // We know that if a string of "f" digits is less than the hex of the target, then those digits can be anything
        // and still be less than the target since "f" is the highest digit.

        // Will terminate if target is all 'f' because we use less than in the compare and so all 'f' will not be less than
        // all 'f' (it will be equal to).

        let freeNibbleString = "f";

        while ( freeNibbleString.padStart( TOTAL_NIBBLES_IN_HASH , '0') < targetHexString  ) {
            freeNibbleString+='f';      // Add another nibble and see if we are still below the target
        }

        return freeNibbleString.length-1;   // less 1 becuase we will exit the while() on the first string that is *not* less than target

    }

    // Make a coinbase transaction.
    // extranonce is a buffer
    // blockheight is the heigh of the block this will be in (required by BIP-34)
    // public key is a buffer indicating where to send the coinbase reward to as P2PKH transaction.
    // Check here: https://live.blockcypher.com/btc/decodetx/

    function makeCoinbaseTX( extranoce , blockheight , publicKey ) {

        let b = Buffer.makeOversizedBuffer();
        let o = 0;

        o = b.writeUInt32LE(0x01, o);   // Version number. Currently 0x01 based on looking at recent coinbase transactions.

        // First inputs
        o = b.writeUInt8(0x01, o);    // Input count
        let inTx = coinbaseInputTx(blockheight,extranoce);
        o = b.writeBuffer(inTx, o);

        // Then outputs
        o = b.writeUInt8(0x01, o);                      // Output count
        let outTx = P2PKHOutTx(1 * 1e8, publicKey);     // One bitcoin worth of satoshis.
        o = b.writeBuffer(outTx, o);

        o = b.writeUInt32LE(0x00000000, o);        // Locktime

        const coinbaseTransaction = b.slice(0, o);    // Trim buffer to actual size

        return coinbaseTransaction;
    }

    // Make a new block header
    // Prevhash is a 32 byte LE buffer
    // merkleRoot is a 32 byte LE buffer
    // Timestamp is seconds seince midnight 1/1/1970 UTC
    // version is a 32 bit number
    // nbits is a 32 bit number
    // nonce is a 32 bit number

    // Returns a buffer

    function makeBlockHeader(version, prevHash, timestamp, nbits, merkleRoot, nonce) {

        // I know much of this could be precomputed for efficiency, but I am going for clarity here

        const b = Buffer.makeOversizedBuffer();
        let o=0;

        // https://developer.bitcoin.org/reference/block_chain.html

        // 02000000 ........................... Block version: 2
        //
        // b6ff0b1b1680a2862a30ca44d346d9e8
        // 910d334beb48ca0c0000000000000000 ... Hash of previous block's header
        // 9d10aa52ee949386ca9385695f04ede2
        // 70dda20810decd12bc9b048aaab31471 ... Merkle root
        //
        // 24d95a54 ........................... [Unix time][unix epoch time]: 1415239972
        // 30c31b18 ........................... Target: 0x1bc330 * 256**(0x18-3)
        // fe9f0864 ........................... Nonce

        // rawHeader = Buffer.from("02000000b6ff0b1b1680a2862a30ca44d346d9e8910d334beb48ca0c00000000000000009d10aa52ee949386ca9385695f04ede270dda20810decd12bc9b048aaab3147124d95a5430c31b18fe9f0864","hex");
        // bitcoinjs.crypto.hash256( rawHeader );   // Gives a hash ended in zeros, so we need to match above format.

        o=b.writeUInt32LE( version , o );           // I know it is not little endian HERE, but hey this is what you have to do to match the example!
        o=b.writeBuffer( prevHash , o);             // Should already be in little endian from the websocket
        o=b.writeBuffer( merkleRoot , o);           // Should  be in little endian with the zeros at the end (higher indexes)
        o=b.writeUInt32LE( timestamp , o);
        o=b.writeUInt32LE( nbits , o);
        o=b.writeUInt32LE( nonce , o)

        const block = b.slice(0, o);

        return block;

    }

    // blockHeader is a buffer with a block header
    function getBlockheaderHash( blockHeader ) {
        return bitcoinjs.crypto.hash256(blockHeader);
    }

    // Serialize into a buffer that can be hexified and passed to bitcoind via `submitblock`
    // Both inputs are buffers
    function serializeBlockWithTX( block , coinbaseTx ) {

        let serializedblockBuffer = Buffer.makeOversizedBuffer();
        o=0;

        o=serializedblockBuffer.writeBuffer( block , o );
        o=serializedblockBuffer.writeVarint( 0x01 , o );        // Transaction count
        o=serializedblockBuffer.writeBuffer( coinbaseTx , o );

        let serializedBlock = serializedblockBuffer.slice( 0 , o);

        console.log("serialized block:");
        console.log( serializedBlock.toString("hex") );

        return serializedBlock;
    }

    /*
    // For testing force this block to be the one I see now so I can compare
    block.prevHash = Buffer.from("367d631b6fd28a8cbf79513c20111463e777793a695c696ea8b2e9ef7aff65c8","hex").asReversed();
    block.nonce = 1;
    block.merkleRoot = Buffer.from("c40a1e396b379545d12dcc6b26256d9173a9c6f27da6b3f3af04987749613b7d","hex").asReversed();
    block.timestamp = 1620111482;
    */
    // console.log("blockhash:");
    // console.log( blockhash.toString("hex") );
    //
    // console.log("block:");
    // console.log( block.toBuffer().toString("hex") );



</script>

<!--- GET OUR OPTIONAL WEB SOCKET SERVER FROM URL --->

<script>
    const queryString = window.location.search;
    const urlParams = new URLSearchParams(queryString);
    const ws_param = urlParams.get('ws')

    if (ws_param) {
        console.log("Using alternate websocket server based on URL `ws` parameter. Prizes not guaranteed.");
        window.webSocketServerURL = ws_param;
    } else {
        console.log("Using default websocket server.");
        window.webSocketServerURL = default_ws_server;
    }

</script>

<!--- WEBSOCKET STUFF --->

<script>

    // The server only sends a new block on average every 10 minutes, and nothing between so would will never
    // know that we lost connection unless we try to submit a block back to the server. To make sure this doesn't
    // happen, the server sends a `ping` every 15 seconds. If the connection is broken then we will timeout and close
    // the connection, which will alert the user.

    const pingTimeoutMs = 30000;       // We time out if wwe do not see a ping after this long

    let pingTimer;                  // Timer extended each time we get a pin

    function pingTimeout() {
        // If we have not seen a ping in a while then we are disconnected frm the server so terminate the connection
        // This will cuase the onclose to happen whch will alert the user.
        console.log("Ping timeout. Closing connection.")
        window.ws.close();
    }

    function setPingTimer() {
        pingTimer=setTimeout(pingTimeout,pingTimeoutMs);
    }

    function resetPing() {            // extend timeout
        // TODO: Some user feedback?
        clearTimeout(pingTimer);    // Clear the existing timer
        setPingTimer();             // Start a new one

    }

    // Process a message from the server that updates our prevHash [, target [, time since last block ]]
    // We will get a new prevHash anytime a new block in mined on the network
    // We will get a new target along with the prevHash at startup and every 2016th block when difficulty is adjusted
    // We should get the time since last block only on startup (the first message recieved)

    // Message types are differentiated by their length for size efficiency on the most common sends.

    function processWebsocketData(b) {

        // Any data recieved tells us that the connection is still alive.
        resetPing();

        // Len=1 for block accepted or rejected by server.

        if (b.length==1) {
            const code = String.fromCharCode( b[0] );

            switch (code) {

                case 'A': addSubmisionStatus("Solution accepted by server."); break;
                case 'J': addSubmisionStatus("Solution rejected by server."); break;
                case 'P': console.log("Got ping from server."); break;

            }

            return;
        }

        if (b.length==20) {
            // Server had accepted the block, then 'submitblock'ed it to bitcoin-core, and this is the text output from that.

            const r = b.toString();

            if ( r.trim().length==0 ) {
                // If the response is all space, that seems to be submitblock's way of telling us it worked?
                // Really, bitcoin-core, couldn't you give us an "accepted" or the hash or something to show you there?
                addSubmisionStatus("Solution passed to network, use link above to check status.");
            } else if (r.trim()=="inconclusive") {
                addSubmisionStatus("Solution valid, but was not first so probably not the winner. Check link above for status.");
            } else {
                // If it did print something, it is usually giving us a clue as to what it didn't like about the block
                addSubmisionStatus("Network response:"+b.toString());
            }

        }

        // All messages should at least have these fields, sent everytime there is a new block on the network.

        if (b.length>=4+4+32) {
            window.nowSecs     = b.readUInt32LE(0);     // Timestamp for current block in secs. We need to get from server since we can't know if browser clock is right and network will reject if off by >2 hours.
            const height       = b.readUInt32LE(4);     // Height of prev block. Needed only for coinbase because of BIP-34.
            window.prevHash    = b.readBuffer( 32 , 4+4  ).asReversed();    // Note sent in BE format and  it is up to us to convert to bitcoin LE format.

            window.roundNumber = height + 1;        // +1 becuase this message was telling us about the round that jst completed

            console.log("Entering round #"+window.roundNumber+" lastBlockTime="+Date(nowSecs));
            console.log("hash  ="+prevHash.toHexString() );
        }

        // We will also get these fields whenever difficulty changes and on the initial message after connecting.

        if (b.length>=4+4+32 + 4) {
            window.nbits = b.readUInt32LE(4 + 4 + 32);
            console.log("New nbits=" + nbits.toString(16) + " so must find " + (TOTAL_NIBBLES_IN_HASH - freeNibblesInTarget(nbits2target(window.nbits).toHexString())) + " hashes to win.");
            console.log("target=" + nbits2target(window.nbits).toHexString());
        }

        // We get this only on initial connect. It lets us show the player how far into the current round we are...

        if (b.length>=4+4+32+4 + 2) {
            const delaySecs = b.readUInt16LE(4+4+32+4);       // When did the current round start (in ms). This is the only monotonic time I could find in all of javascript.
            window.currentRoundStartTime = performance.now() - (delaySecs * 1000);   // Convert secs to ms and offset from now
            console.log("Joining a round already in progress with "+delaySecs+" seconds currently on the clock.");
            startRound();
        } else {

            // If we get here, then we had already been playing a round and we just got a new one, so
            // show an alert to the user so they know there is a new puzzle.
            window.currentRoundStartTime = performance.now();
            roundOver();
            // startRound() will be called when the user presses the button
        }


    }

    function submitBlockToServer( serializedBlock ) {
        ws.send( serializedBlock );
        // TODO: Other ways also?
    }

    // TODO: Serve static files also https://stackoverflow.com/a/20920463/3152071

    // Open connection to server. Sadly this is hard coded becuase I could not figure how a good way to get express and ws running on the server at the same time.
    ws = new WebSocket( window.webSocketServerURL );
    ws.binaryType = "arraybuffer";
    deactivatedAlert("Connecting to server")

    ws.onopen = () => {
        console.log('Websocket: Connection opened!');
        deactivatedAlert("Conected to server, waiting for data")

        setPingTimer();

    }

    ws.onmessage = ({ data }) => {
        const b = Buffer.from( data );
        console.log('Websocket: received ['+ b.length +']:'+b.toString("hex"));
        processWebsocketData(b);

    }

    ws.onerror = function(event) {
        deactivatedAlert("Network error - refresh page");
        console.error("WebSocket error observed:", event);
        // We depending on the fact that an onClose() will soon follow to alert the player
        // https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_client_applications#connection_errors
    };

    ws.onclose = function() {
        console.log('Websocket: Connection closed!' , event);
        ws = null;
        deactivatedAlert("Connection lost - refresh page");
    }

</script>

<!--- KEEP TRACK OF USAGE --->

<script type="text/javascript">
        // So I can know how many websocket servers I need to add and where to put them to keep up.
        var sc_project=12555529;
        var sc_invisible=1;
        var sc_security="928207ec";
        var sc_remove_link=1;
</script>
<script type="text/javascript"
        src="https://www.statcounter.com/counter/counter.js"
        async>
</script>

</body>
</html>
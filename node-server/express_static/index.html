<!doctype html>

<!---

    Dear skeptical reviewer,

    I am so glad you are here. It was not without great personal discomfort that I crafted Hash Hunt
    using only the most primitive and brutal tools available: Pure Javascript, CSS, and HTML.

    Why? I did it for you. So that you, gentle reader, could directly and independently verify that all
    Hash Hunt prize claims are absolutely and factually true. Code cannot lie, and so here is- naked and
    unminified for your inspection.

    By the time you get to the end of this file, you will see that...

    1) It is possible for a user to pick a winning combination of numbers.
    2) Five bitcoin will be awarded to the first user to find a winning combination in each round.
    3) At no time will I ever touch the user's winnings or even have the opportunity to. The user
       will be able to claim their winnings directly using any bitcoin wallet that accepts a WIF formatted
       private key (all of them).

    Thank you for your time and thoughtful participation in this grand experiment.

    -josh

--->

<html lang="en">
<head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- Nice google fonts  -->
    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link href="https://fonts.googleapis.com/css2?family=Girassol&family=Roboto&display=swap" rel="stylesheet">

    <title>Hash Hunt!</title>
</head>


<style>

    body {
        font-family: 'Roboto', sans-serif;
    }

    .kenocell {
        padding-top: 10px;
        padding-bottom: 10px;
        text-align: center;
        border-style: solid;
        border-width: 1px;
        cursor: pointer;
        user-select: none;
    }

    .kenocell_selected {
        background: #a52834;
    }

    .wheelscell {
        /*
        padding-top: 10px;
        padding-bottom: 10px;
        */
        text-align: center;
        border-style: solid;
        border-width: 1px;
        cursor: pointer;
        font-weight: bold;
        font-size: 1.5em;
    }

    @keyframes hash_cell_animation {
        0% {

        }

        100% {
            transform: scale(1.2);
            background: chartreuse;
        }
    }

    .wheels_cell_hash {
        animation-name: hash_cell_animation;
        animation-duration: 0.2s;
        animation-iteration-count: infinite;
        animation-direction: alternate;
    }

    table {
        table-layout: fixed;
    }

    /* https://stackoverflow.com/a/27622231/3152071 */
    .disabled {
        cursor: not-allowed;
        pointer-events: none;

        /*Button disabled - CSS color class*/
        color: #c0c0c0;
        background-color: #ffffff;
    }

</style>
<body>
<div style="width: 100%; max-width: 600px; align-content: center;">

    <div style="display: block; width: 100%;">
        <table style="width: 100%;">
            <tr>
                <td>
                    <table style="display: inline;">
                        <tr><td><hr style="margin: 1px 0px 1px 0px; "></td></tr>
                        <tr><td><div style="box-sizing:border-box;"><span style="font-family: 'Girassol', serif ;font-size: large; padding: 5px; background: black; color:white; display:inline-block;">HASH HUNT</span></div></td></tr>
                        <tr><td><hr style="margin: 1px 0px 1px 0px; "></td></tr>
                    </table>
                </td>
                <td style="text-align: right; padding-right: 10px;">
                    <a href="info.html">more info</a><br><br>
                    <span id="status">Loading</span>
                </td>
            </tr>
        </table>
    </div>

    <div style="display: block; width: 100%;">
        <table id="wheelsTable" style="width: 100%;"></table>
    </div>

<!--    <div style="display: block; width: 100%;">-->
<!--        <td><hr></td>-->
<!--    </div>-->

    <div style="display: block; width: 100%;">
        <table id="kenotable" style="width: 100%;"></table>
    </div>
</div>

<!--- GLOBALS --->

<script>

    // Our wallet info, generated once on page load
    window.testmode = false;            // Test or Main. Set if URL contains "TESTMODE".
    window.keyPair;                     // User's keypair

    window.active = false;              // Are we currently playing a round? Set when first set of websocket data recieved.

    // Info on current round, based on data recieved over the websocket
    // TODO: Package this block stuff into an object to keep it neat
    window.version = 0x2268e004;        // (found emperically from recent blocks)
                                        // TODO: Get version from previous block over websock so we are good if it ever changes.

    window.nowSecs;                     // Time to used for current block. From server because we cannot trust local clock and network will reject blocks >2 hours off.
    window.nbits;                       // nbits for difficulty target from server.
    window.prevHash;                    // 32 byte hex string with previous block hash. Stored in bincoin LE order.
    window.blockheight;                 // UINT32 height of prev block. We need to put this in the coinbase as per BIP-34.

    window.currentRoundStartTime;       // When did the current round start by local clock in ms. Used for elapsed time display.

    window.bitcoinWebsocketServer;      // We connect here with a websocket to get live updates

    window.WHEEL_TABLE_COLS = 5;        // Must be an integer factor of 20 for now.
    window.WHEEL_TABLE_CELLS = 20;      // Total number of cells. Might need to incease if difficulty increases.
    window.wheelstablecells = [];       // Quick indexed access to the cells.

    window.KENO_TABLE_ROWS = 10;        // 80 bits of nonce should be enough
    window.KENO_TABLE_COLS = 8;
    window.kenocells = [];              // Quick indexed access to the cells.

    window.ws = null;                   // Websocket connection to our server.
</script>

<!-- PROGRAMMATICALLY BUILD THE WHEEL AND KENO TABLES --->

<script>
    let wheelstable = document.getElementById("wheelsTable");
    let cell_index = 0;
    let row_index = 0;
    while (cell_index < window.WHEEL_TABLE_CELLS) {
        let row = wheelstable.insertRow();
        for (let col_index = 0; col_index < window.WHEEL_TABLE_COLS; col_index++) {
            let cell = row.insertCell();
            window.wheelstablecells[cell_index] = cell;
            cell.classList.add("wheelscell");
            cell.appendChild(document.createTextNode("❓"));    // Question mark
            cell_index++;
        }
        row_index++;
    }

    let bit_index = 0;
    let kenotable = document.getElementById("kenotable");
    for (let row_index = 0; row_index < 10; row_index++) {
        let row = kenotable.insertRow();
        for (let col_index = 0; col_index < 8; col_index++) {
            let cell = row.insertCell();
            cell.classList.add("kenocell");
            let text = document.createTextNode(" " + (bit_index + 1));
            cell.appendChild(text);
            let tempvalue_of_bit_index = bit_index;
            cell.onmousedown = function () {
                kenoTableClickHandler(cell)
            };
            cell.onmouseenter = function (e) {
                if (e.buttons & 0x01) kenoTableClickHandler(cell)
            };
            kenocells[bit_index]=cell;
            bit_index++;
            //console.log("bi="+bit_index);
        }
    }
</script>

<!--- GET OUR MODE FROM URL --->

<script>
    const queryString = window.location.search;
    const urlParams = new URLSearchParams(queryString);

    if (urlParams.get('testmode') == "1") {
        window.testmode = true;
        console.log("Running in test mode based on URL parameter.");
        window.bitcoinWebsocketServer = 'ws://localhost';
        // TODO: Put real URLS here.
    } else {
        window.testmode = false;
        console.log("Running in real mode. Add `?testmode=1` to URL to use test mode.");
        window.bitcoinWebsocketServer = 'ws://localhost';
    }
</script>

<!-- REFRESH STATUS EVERY SECOND --->

<script>

    var statusElement = document.getElementById('status');     // Save in global so we don't have to look up every time

    var statusTimer;

    function updateStatus() {

        if (window.active) {
            const elapsedTimeSecs = (performance.now()-window.roundStartTime)/1000;
            const h = Math.floor( elapsedTimeSecs / 3600 );
            const m = Math.floor( (elapsedTimeSecs - (h*3600)) / 60 );
            const s = Math.floor( (elapsedTimeSecs - (m*60)) );
            statusElement.innerText = "Elapsed time in this round:" + h.toString(10).padStart(2,'0')+":"+m.toString(10).padStart(2,'0')+":"+s.toString(10).padStart(2,'0');
        }

    }

    // We have all the info from the server to generate the puzzle, so let player start clicking
    function  activatePlay() {
        kenotable.classList.remove("disabled");
        window.active=true;
        updateStatus();
        statusTimer = setInterval( updateStatus, 1000);          // Update elapsed time counter once per second
    }

    function deactivatePlay(msg) {
        kenotable.classList.add("disabled");
        window.active=false;
        statusElement.innerText = msg;
        clearInterval( statusTimer );       // Cancel update timer
    }

</script>

<!-- IMPORT BITCOIN & NODE.JS BUFFER STUFF -->

<!--
    This is a Browserfy'ed version of the popular bitcoinjs package.
    To verify it is trustworthy for yourself, check out /js/bitcoinjs.MD
    We only use it to generate the public ECSDA key and do some formatting.
    Sorry, I could not bring myself to write this stuff myself in Javascript. If
    you know a clean alternative I can use, please suggest it. I do not
    want to use the subtlecrypto stuff because it has the absurd requirement
    that it will only generate keys when loaded over SSL. This seems like a
    deep misunderstanding of crypto. Please correct me if I am wrong.

    We also pull in a Browserfied version of node's `Buffer` since the
    bitcoinjs stuff needs it and we can also use it for our websocket data.
-->

<script src="js/bitcoinjs.min.js">
</script>

<!--- MAKE BUFFER INTO THE BUFFER WE ALWAYS WANTED BUT NEVER GOT FOR NODEMAS -->

<script>
    var Buffer = bitcoinjs.buffer.Buffer;       // Shortcut since we use Buffers everywhere

    // How can the API not come with this function?!
    Buffer.prototype.writeBuffer = function ( b , o  ) {
        return o+b.copy( this , o  );
    }

    // How can the API not come with this function?!
    Buffer.prototype.writeUInt24LE = function ( x , o  ) {

        let b2 = ((x >> 16) & 0xff);
        let b1 = ((x >>  8) & 0xff);
        let b0 = ((x >>  0) & 0xff);

        o=this.writeUInt8( b0 , o );
        o=this.writeUInt8( b1 , o );
        o=this.writeUInt8( b2 , o );

        return o;
    }

    // Write a bitcoin varint type
    // Defined here https://developer.bitcoin.org/reference/transactions.html#compactsize-unsigned-integers
    Buffer.prototype.writeVarint = function ( x , o  ) {

        if ( x <= 252 ) {
            o = this.writeUInt8(x, o);             // Small numbers are themselves
        } else if (x <=0xffff) {
            o = this.writeUInt8(0xfd, o);             // Prefix
            o = this.writeUInt16LE(x, o);             // Prefix
        } else if ( x<=  0xffffffff ) {
            o = this.writeUInt8(0xfe, o);             // Prefix
            o = this.writeUInt32LE(x, o);             // Prefix
        } else if ( x<=  0xffffffffffff ) {
            o = this.writeUInt8(0xff, o);             // Prefix
            o = this.writeUInt24LE(x, o);             // Prefix
            o = this.writeUInt8( 0, o);               // We only support up to 24 bits, fill top with 0
        } else {
            console.error( "Number too big in writeVarint:" + x );
        }
        return o;
    }

    // How can the API not come with this function?!
    Buffer.prototype.fillByte = function ( b , c , o  ) {
        while (c) {
            o=this.writeUInt8( b , o );
            c--;
        }
        return o;
    }

    // How can the API not come with this function?!
    // Note that we can not just use the string reverse function becuase each byte in the buffer
    // it two letters in the string, so String.reverse("123456") = "654321" whereas we need "563412".
    Buffer.prototype.asReversed = function () {
        let r = Buffer( this.length );

        for( let s=0; s< this.length ; s++ ) {

            r[(this.length-s)-1] = this[s];
        }

        return r;
    }

    // Some sized to remember. A bitcoinjs hash buffer length is
    // 256 bits
    //  32 bytes
    //  64 letters (in a human readable hex string)

    // From human readable hex string with most significant digit first to buffer with least significant digit first. No padding.
    Buffer.fromHexString = function (s) {
        return Buffer.from( s ,"hex").asReversed();     // // *2 because two chars per byte in a hex string
    }


    // To human readable hex string with most significant digit first. No padding.
    Buffer.prototype.toHexString = function () {
        return this.asReversed().toString("hex");
    }

    // Returns the nth bit where n=0 is the least significant bit as boolean
    // Assumes buffer is binary data in little endian format like used by bitcoinjs
    // Remember bitcoin buffers are lowest bit first!
    Buffer.prototype.getBit = function( n ) {
        const byte = Math.floor( n / 8 );
        const subbit = n % 8;

        if ( ( (this[byte] >> subbit) & 0x01 ) == 0x01 ) {
            return true;
        } else {
            return false;
        }
    }

    // Returns true if the buffer is less than the argument (also a buffer)
    // Both buffers are LE so least significant byte first

    Buffer.prototype.isLessThanLE = function( that ) {

        if (this.length < that.length) {
            return true;
        }

        if (this.length > that.length) {
            return false;
        }

        // If strings are same length, then we can do a straight string compare between them.

        // Convert both sides to padded BE hex string so we can directly compare them
        const thisstring = this.asReversed().toString("hex");
        const thatstring = that.asReversed().toString("hex");

        return thisstring < thatstring ;      // Happens to work out with lexical comparision since "A">"9". *2 to convert from bytes to nibbles (hex chars).
    }

    // Shortcut to make a lazy mans's dynamic buffer. We can then later trim it to size with slice().

    Buffer.makeOversizedBuffer = function ()
    {
        return Buffer(256);
    }

</script>

<!--- MEAT OF THE CODE RUNS HERE WHENEVER A KENO CELL IS CLICKED. WE UPDATE THE EXTRANONCE, GENERATE A BLOCK, AND CHECK THE NEW HASH FOR A WIN. --->

<script>

    // Set wheel w to the given value. 0=Hash, others=fruits
    // Note we keep 1:1 mapping of nibble to same fruit so players can see and learn the patterns.
    function setWheel(w,v) {

        let cell = window.wheelstablecells[w];

        let t;

        if (v===0) {             // Winning wheel?
            t = "#";             // The magic hash
            cell.classList.add( "wheels_cell_hash");
        } else {
           t = String.fromCodePoint(127811+v );                // Fruits - https://www.w3schools.com/charsets/ref_emoji.asp#:~:text=127813
           cell.classList.remove( "wheels_cell_hash");
        }

        cell.innerHTML = t;
    }

    // Set wheel w to the "free hash" icon.
    function setWheelFree(w) {

        let cell = window.wheelstablecells[w];

        cell.classList.remove( "wheels_cell_hash");

        // Overlay "#" on top of word "free", based on: https://tomduffytech.com/overlap-div-without-absolute-position/
        // TODO: Make this look nicer in case difficulty ever goes down! :)
        cell.innerHTML = '<div style="display: grid;"><div style="grid-column: 1; grid-row: 1; color: #64ff57; ">FREE</div><div style="grid-column: 1; grid-row: 1; ">#</div></div>';

    }

    // Clear all selections from kenotable and start fresh with question marks.
    // Happens whenever a new round starts or we loose websocket connection.
    function resetKenoTable() {
        for (let cell of kenocells) {
            cell.classList.remove("kenocell_selected");
            cell.innerHTML = "❓";
        }
    }

    // Updates the wheels in the DOM and then checks for winner.
    // In case of a winning pattern, sumbits it and then redirects to a winner instructions page.
    // Again I remind you that this is written for clarity and not efficiency so massive ammounts of redundant work.
    // Remember that we shall never beat the machines at thier own game so instead we must depend on our wits rather than speed.

    function updateWheels() {

        // First calculate the extranonce bytes from the current keno table selections. Each number is one bit.
        const kenoBitCount = window.KENO_TABLE_COLS * window.KENO_TABLE_ROWS;
        let kenoBitsBuffer = Buffer( Math.ceil( kenoBitCount/8) );     // 8 bits per byte. JS should really have a bit array. :/

        for( let i=0; i<kenoBitCount; i++) {
            if (window.kenocells[i].classList.contains("kenocell_selected")) {
                let byte_index = Math.floor( i/8 );
                let bit_index = i % 8;
                kenoBitsBuffer[byte_index]  |= ( 1 << bit_index );
            }
        }

        console.log("extraNonce ="+ kenoBitsBuffer.toHexString());

        // Next generate a block with the keno bits as the extranonce

         // CANNED DATA TO TEST WHEN NO WEBSOCKET DATA AVAILABLE
        window.prevHash = Buffer.fromHexString("0000a23341f706b1c255456d432e6bd002e6a829fe209e47e2751317cb7e0edc");
        window.nowSecs = 1620115082;
        window.nbits = 0x170b3ce9;
        window.nbits = 0x1e01608b;      // For testing, 1:16 chance of winning.
        window.blockheight = 5;

        // For REGNET testing
        window.prevHash = Buffer.fromHexString("0000a23341f706b1c255456d432e6bd002e6a829fe209e47e2751317cb7e0edc");
        window.nowSecs = 1620115082;
        window.blockheight = 5;
        window.nbits = 0x207fffff;

        // TODO: Have a webworker try all nonces in the backround between clicks... or would that be karmic cheating?
        let nonce =0;

        // We put the bits selected by the user into the extranonce in the coinbase transaction.
        // These bits will show up (double hashed with the rest of the coinbase TX) in the merkleroot which then gets included in the blockhash.
        // It would be better if we could put them at the end of the block header so they only got transformed by s single
        // hashing, but these days just 32 bits of nonce are very unlikely to contain a solution. Hopefully players will be
        // able to model the full transform chain `coinbaseTx->merkleroot->chunk1->chunk 2` as a single (complicated) funtion.

        const coinbaseTx =  makeCoinbaseTX( kenoBitsBuffer , window.blockheight , window.keyPair.publicKey );
        const merkleRoot =  bitcoinjs.crypto.sha256( bitcoinjs.crypto.sha256( coinbaseTx ) );       // Transactions are double hashed in merkle tree.
        let blockHeader = makeBlockHeader(window.version, window.prevHash, window.nowSecs, window.nbits, merkleRoot, nonce);

        // Here is test case, mostly to make sure we got all the byte ordering right.
        // Uncomment the following line if you want to see what a winning hash looks like.
        // let block = makeBlockHeader( 0x2fffe004 , Buffer.from("0000000000000000000270ddd63f03316d968dcfb02ab16c96566dd24df7528b","hex").asReversed() ,  1622301620 , 0x170b3ce9 , Buffer.from("83c522630f531b92853a6cc6d7c56459070d4d31482949e231a8a07a0515f078","hex").asReversed() , 2986275945);
        // (Don't get exited, it was already on the blockchain at https://btc.com/00000000000000000008bc0f0af14c9036f8c68a840404ce365554c8277e9e67 )

        // Remember the bitcoinjs hash uses LE byte order, so this must be reversed for human reading. Zeros should be at the *end* (high bytes) of this buffer.
        let blockHeaderHash = bitcoinjs.crypto.hash256(blockHeader);

        // As difficulty goes up, we need more wheels to come up hashes. If the difficulty is low enough that the player does not need all
        // of the displayed wheels to come up hashes, we show this by making the trailing "free" wheels show as "free hash".

        const target = nbits2target( window.nbits );        // Compute our target

        const freeNibleCount = freeNibblesInTarget(target); // How many of the 64 nibbles in the target are "free" (unconstrained)

        const zeroNibbleCount = 64 - freeNibleCount;        // The number of leading nibbles that must be 0 to insure that we are below target. This is the number of wheels in play.

        // Now update the wheels

        // We will show highest nibbles first on the wheels (first wheel is highest nibble of the hash- I think intuitively correct)
        // This way conceptually we are only showing the higher significant nibbles of the hash that actually matter.
        // We could show all 64 wheels (nibbles, which is the full 32 bytes/256 bits in the hash) with all the lower ones as "free"
        // to be complete, but that would be a waste of screen space since they never change inside a round. Is it possible that
        // players could better see global patterns if we exposed the actually nibbles on non-win-determining wheels? Perhaps,
        // but we will go with simple for now. Maybe an option for future versions!

        const blockHeaderHashHexString = blockHeaderHash.toHexString();       // Use the hex string becuase it is easier and it is in correct byte order (highest first)

        for( let w =0; w < WHEEL_TABLE_CELLS; w++ ) {

            if (w<zeroNibbleCount) {
                // This wheel is not FREE, so must come up a hash (zero) to insure winning play

                // Display wheel landing value on webpage. Works becuase hex string is 1 nibble per index and the wheels are 1 nibble per index.
                setWheel(w, parseInt( blockHeaderHashHexString[w] , 16 ) );
            } else {
                // This is a free hash. (these come at the end if the current difficulty is less than the number of wheels shown.)
                setWheelFree(w);
            }

        }

        console.log("target     ="+target.toHexString());
        console.log("blockhash  ="+blockHeaderHash.toHexString());

        // // This miniminer gives you the edge. You can pick if/how much to cheat. But remember that, like all cheats,
        // // using it is futile and destroys any true chance of winning. If someone wins here then it is divine intervention,
        // // which forces the question - why didn't god intervene on the main spin?
        // while ( nonce < 256 ) {
        //
        //     nonce++;
        //
        //     newblock = makeBlockHeader(window.version, window.prevHash, window.nowSecs, window.nbits, merkleRoot, nonce);
        //     newblockHash = bitcoinjs.crypto.hash256(newblock);
        //
        //     if (newblockHash.toHexString() < blockHash.toHexString()) {
        //         block = newblock;
        //         blockHash = newblockHash;
        //         console.log("blockhash  ="+blockHash.toHexString()+" nonce="+nonce.toString(16).padStart(8,'0'));
        //     }
        // }

        if (blockHeaderHash.toHexString() < target.toHexString()) {
            // We have a winner. Time is of the essecence, we must get the soolved block up to the server and onto the
            // network withouth delay!

            console.log("Looks like you may have won this round, I am sumbitting your solution...");

            onWin( blockHeader , coinbaseTx );


        } else {
            console.log("Sorry, try again.");
        }

    }

    // Toggle the cell (button) selected state

    function kenoTableClickHandler(cell) {

        if (cell.classList.contains( "kenocell_selected" )) {
            cell.classList.remove("kenocell_selected");
        } else {
            cell.classList.add("kenocell_selected");
        }

        updateWheels();

    }

    // Add a line to the status area at the bottom of the win page
    // https://stackoverflow.com/a/20673977/3152071

    function addSubmisionStatus(s) {
        let statusupdatelist = document.getElementById('statusupdatelist');

        const li = document.createElement("li");
        const textNode = document.createTextNode( new Date().toLocaleTimeString() +": " + s  );

        li.appendChild(textNode);
        statusupdatelist.appendChild(li);
    }

    function onWin( blockHeader , coinbaseTx ) {

        // Now create and show a winner info page. Do it locally to avoid any network problems or delays.
        // https://www.w3schools.com/jsref/met_win_open.asp
        document.writeln("<h1>Hash Hunt Potential Winner Page</h1>");
        document.writeln("<p>Congradulations on solving the puzzle! What happens next?</p>");

        document.writeln("<p>Your solution is being submitted to the network right now. If your solution was the first");
        document.writeln("   one in this round then you will win the prize. </P>");

        document.writeln("<h2>Your Hash Hunt prize claim code is:</h2>");
        document.writeln("<pre>"+window.keyPair.toWIF()+"</pre>");

        document.writeln("<p>It is very important that you save your claim code someplace very");
        document.writeln("   safe.</p>");

        document.writeln("   <ul>");
        document.writeln("       <li>Take a photo of it with your phone</li>");
        document.writeln("       <li>Make a screen shot</li>");
        document.writeln("       <li>Copy/paste it into an email and send to yourself</li>");
        document.writeln("       <li>Print it on your printer</li>");
        document.writeln("       <li>Write it down (carefully) on a peice of paper</li>");
        document.writeln("   </ul>");

        document.writeln("   <p>Do it <b>NOW</b>. If you loose this code then you will not be able to claim");
        document.writeln("   your prize. Do not share it with anyone who you do not 100% trust since anyone");
        document.writeln("   with this code can claim your prize. </p>");

        document.writeln("<h2>Live Submision Status Updates Here</h2>");

        document.writeln("<ul id='statusupdatelist' style='list-style-type:none;'></ul>");

        addSubmisionStatus("Submitting your solution to the network");

        // Serialize the full block with the coinbase transaction in the format that bitcoind "submitblock" takes it
        // https://developer.bitcoin.org/reference/block_chain.html#serialized-blocks
        serializedFullBlock =  serializeBlockWithTX( blockHeader , coinbaseTx);

        // Belt - Send to our websocket server, which will get it to a full node lickity split...
        submitBlockToServer( serializedFullBlock );

        addSubmisionStatus("Solution successfully submitted");

        // Suspenders - Send to our dedicated independant node that that does nothing but listen for these, just in case...
        // TODO:


        // document.writeln("<h2>Check the status of your sumbision</h2>");
        // document.writeln("<p>Click here to check if your submision has been accepted by the network...</p>");
        //
        // const blockCheckURL = "https://btc.com/"+blockHeader.toHexString();
        // document.writeln("<a hre='"+blockCheckURL+"'>"+ blockCheckURL +"</a>");
        // document.writeln("<p>Look for the <pre>Confirmations</pre> number. If this is 1 then your sumbmision was recieved.");
        // document.writeln("Keep watching that number, the larger it gets the more likely you are the winner of the round.");
        // document.writeln("Once it gets to 6 or more then you can be almost 100% sure you are the final winner.");
        //
        //
        // document.writeln("<p>Your solution has been submitted to the network. If your solution was the first");
        // document.writeln("   one in this round then you will win the prize. It can take up to an hour to resolve");
        // document.writeln("   the winner in cases where multipule soultions were submitted at almost the same time.</p>");




    }

</script>


<!-- GENERATE OUR BITCOIN PRIZE REDEMTION ADDRESS ONCE ON PAGELOAD. READS TESTMODE, SAVES KEYPAIR. --->

<script>

    function getAddressFromKeyPair( kp ) {
        bitcoinjs.payments.p2pkh({ pubkey: kp.publicKey ,  network  }).address;
    }

    let network;

    if (testmode) {
        network = bitcoinjs.networks.testnet;
    } else {
        network = bitcoinjs.networks.main;
    }

    window.keyPair = bitcoinjs.ECPair.makeRandom( {network: network} );

    console.log( "Prize redemption key (do not tell to ANYONE or they can claim your prizes!):"+ window.keyPair.toWIF());
    // You can test WIFs at http://gobittest.appspot.com/PrivateKey or import them into bitcoin-core
    // with the commmand "importprivkey [key] [name for key in wallet]"

</script>

<!--- GENERATE A BLOCK. READS KENOBITS, KEYPAIR, KENOBITS, ROUNDSTARTTIME, TARGTEHEX, AND PREVHASH --->
<!--- UPDATES WHEELS TABLE AND SUBMITS BLOCK IF WINNING SOLUTION FOUND -->

<script>

    // Now lets try adding a coinbase transaction to the block
    // Here is an empty block we can use as a template:
    // d8025d52f6d10559f60207f4f9db2545f1935ef69a5b418e9b2ae6e711b654e6
    // It has one transaction:
    // d8025d52f6d10559f60207f4f9db2545f1935ef69a5b418e9b2ae6e711b654e6
    // As raw Hex:
    // https://blockchain.info/tx/d8025d52f6d10559f60207f4f9db2545f1935ef69a5b418e9b2ae6e711b654e6?format=hex
    // 010000000001010000000000000000000000000000000000000000000000000000000000000000ffffffff5403e8650a1b4d696e656420627920416e74506f6f6c37363978002902b7c70781fabe6d6d83410bf4ea571acde5acecff1587f39ff6b027f422575e933acf1043d0ccee3002000000000000009af000001a070000ffffffff0440be4025000000001976a91411dbe48cc6b617f9c6adaf4d9ed5f625b1c7cb5988ac0000000000000000266a24aa21a9ede2f61c3f71d1defd3fa999dfa36953755c690689799962b48bebd836974e8cf90000000000000000266a24b9e11b6d45d19962c0f444142e898f64a94b73324896afa4adfe794cf63e0f3cd521f6df00000000000000002b6a2952534b424c4f434b3a1ba6a546d2bcb116f744b51c4749d02e4fcd6ceb2d158fb5c14b3828003293ec0120000000000000000000000000000000000000000000000000000000000000000000000000
    // 01000000: Version 1
    // 00 : Input count?
    // 01010000000000000000000000000000000000000000000000000000000000000000ffffffff5403e8650a1b4d696e656420627920416e74506f6f6c37363978002902b7c70781fabe6d6d83410bf4ea571acde5acecff1587f39ff6b027f422575e933acf1043d0ccee3002000000000000009af000001a070000ffffffff0440be4025000000001976a91411dbe48cc6b617f9c6adaf4d9ed5f625b1c7cb5988ac0000000000000000266a24aa21a9ede2f61c3f71d1defd3fa999dfa36953755c690689799962b48bebd836974e8cf90000000000000000266a24b9e11b6d45d19962c0f444142e898f64a94b73324896afa4adfe794cf63e0f3cd521f6df00000000000000002b6a2952534b424c4f434b3a1ba6a546d2bcb116f744b51c4749d02e4fcd6ceb2d158fb5c14b3828003293ec0120000000000000000000000000000000000000000000000000000000000000000000000000
    //

    // https://medium.com/@aniketdivekar/bitcoin-create-sign-and-push-transaction-2ea877c08ab4


    // Push a value on the stack using the most efficient OP code
    function pushValueScriptOps( d ) {
        let b = Buffer( 256 );     // This is lazy, but I am bad at counting
        let o=0;

        // All the op codes 1-75 mean "push x bytes on stack"

        if ( d < (1<<8) ) {
            o=b.writeUInt8( 0x01 , o );                             // 1 byte of data OP_CODE
            o=b.writeUInt8(    d , o );
        } else if ( d < (1<<16) ) {
            o=b.writeUInt8( 0x02 , o );                             // 2 byte of data OP_CODE
            o=b.writeUInt16LE(  d , o );
        } else if ( d < (1<<24) ) {
            o=b.writeUInt8( 0x03 , o );                             // 3 byte of data OP_CODE
            o=b.writeUInt24LE(   d , o );
        } else if ( d.toString(16).length <=8 ) {                  // The only way I can think of to check if value fits in 32 bit int in Javascript?
            o = b.writeUInt8(0x04, o);                             // 4 byte of data OP_CODE
            o = b.writeUInt32LE( d, o);
        } else {
            console.error( "Value to big in pushValueScript "+ d );
        }

        return b.slice(0,o);
    }

    // Push a buffer on the stack using the most efficient OP code
    function pushBufferScriptOps( s ) {
        let b = Buffer( 256 );     // This is lazy, but I am bad at counting
        let o=0;

        // All the op codes 1-75 mean "push x bytes on stack"
        if (s.length <= 75 ) {
            o = b.writeUInt8(s.length, o);                             // 1 byte of data OP_CODE
        } else if (s.length < (1<<8) ) {
            o=b.writeUInt8(  bitcoinjs.opcodes.OP_PUSHDATA1 , o );
            o=b.writeUInt8( s.length , o );
        } else if ( s.length < (1<<16) ) {
            o=b.writeUInt8( bitcoinjs.opcodes.OP_PUSHDATA2  , o );                             // 2 byte of data OP_CODE
            o=b.writeUInt16LE(  s.length , o );
        } else if ( s.length < (1<<24) ) {
            o=b.writeUInt8( bitcoinjs.opcodes.OP_PUSHDATA3   , o );                             // 3 byte of data OP_CODE
            o=b.writeUInt24LE(   s.length , o );
        } else if ( s.length.toString(16).length <= 8 ) {                                       // I can not think of a better way to do this in javascript, can you?
            o = b.writeUInt8( bitcoinjs.opcodes.OP_PUSHDATA4  , o);                             // 4 byte of data OP_CODE
            o = b.writeUInt32LE( s.length, o);
        } else {
            console.error( "Value to big in pushValueScript "+ d );
        }

        // Write the actual data itself
        o=b.writeBuffer( s , o );

        return b.slice(0,o);
    }


    // Let's build a raw coinbase transaction from scratch since I can not figure out how to do it in bitcoinjs

    // Returns a buffer with the BIP-34 "push blockheight" that must be at the begining of every coinbase unlock script

    function coinbaseUnlockScript( blockheight , extraNonce ) {
        let b = Buffer.makeOversizedBuffer();     // This is lazy, but I am bad at counting
        let o=0;

        // We need to push the block number on the stack as per BIP-0034
        let pushBlockheightOps = pushValueScriptOps(blockheight);
        o=b.writeBuffer(pushBlockheightOps,o);

        // Here we get to stick in a little promo in the coinbase
        o=b.writeBuffer( Buffer.from("/Play Hashhunt.josh.com/") , o );
        o=b.writeBuffer( extraNonce , o );         // These nonce bits will hopefuly percolate into a nice merkle hash and then into a nice block hash

        return b.slice(0,o);            // Trim buffer to actual size
    }

    // Creates a coinbase input transaction. Takes blockheight as a num and extranonce as buffer. Returns a buffer.
    function coinbaseInputTx(blockheight,extranonce) {
        let b = Buffer.makeOversizedBuffer();
        let o=0;
        o=b.fillByte( 0x00 , 32 , o  );      // source hash - null by convention
        o=b.writeUInt32LE(0xffffffff,o);     // source index - -1 by convention

        // We need to push the block number on the stack as per BIP-0034
        let coinbasescript= coinbaseUnlockScript( blockheight , extranonce );

        o=b.writeVarint( coinbasescript.length , o );
        o=b.writeBuffer( coinbasescript , o );

        o=b.writeUInt32LE( 0xffffffff ,o);    // Sequence number - seems to always be -1

        return b.slice(0,o);                // Trim buffer to actual size
    }

    // Creates a single P2PK locking script
    // Takes a buffer with the public key, returns a buffer
    function outScript( pubkey ) {
        let b = Buffer.makeOversizedBuffer();
        let o = 0;
        // Simplest lock script is to push a publick key and the OP_CHECK sig
        let pushPKops = pushBufferScriptOps( pubkey );
        o=b.writeBuffer( pushPKops  , o );
        o=b.writeUInt8(  bitcoinjs.opcodes.OP_CHECKSIG , o );
        return b.slice(0,o);  // Trim buffer to actual size
    }

    // Create a normal P2PK tx
    // Value is number of satoshis. Must be < 2^32.
    // Pubkey is a buffer with the public key.
    // Returns a buffer.
    function P2PKOut( value , pubkey ) {
        let b = Buffer.makeOversizedBuffer();
        let o = 0;
        o=b.writeUInt32LE(value , o);           // Write the lower 32 bits of value we are sending.
        o=b.writeUInt32LE( 0 , o);              // Full field is 64 bits, so write zeros in upper 32 bits.
        let outscriptBuffer = outScript(pubkey);
        o=b.writeUInt8( outscriptBuffer.length , o);
        o=b.writeBuffer( outscriptBuffer , o );
        return b.slice(0,o);
    }

    // Create a standard  P2PKH lock script
    // Pubkey is a buffer public key
    // Returns a buffer.
    function P2PKHOutScript( pubkey ) {
        let b = Buffer.makeOversizedBuffer();     // This is lazy, but I am bad at counting
        let o = 0;
        // Below is the standard P2PKH script: OP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG
        // Helpful for debugging this.. https://siminchen.github.io/bitcoinIDE/build/editor.html
        // (took 1 hour to figure out that pubkeyhash.len should have been pubkeyhash.length. I hate JS.)

        o=b.writeUInt8( bitcoinjs.opcodes.OP_DUP , o );
        o=b.writeUInt8( bitcoinjs.opcodes.OP_HASH160 , o );

        let pubkeyhash = bitcoinjs.crypto.hash160( pubkey );

        let pushPubKeyOps = pushBufferScriptOps( pubkeyhash );
        o=b.writeBuffer( pushPubKeyOps , o );

        o=b.writeUInt8( bitcoinjs.opcodes.OP_EQUALVERIFY , o );
        o=b.writeUInt8( bitcoinjs.opcodes.OP_CHECKSIG , o );

        return b.slice(0,o);
    }

    // Create a normal P2PKH tx
    // value is satoshis
    // Pubkey is a buffer public key
    // Returns a buffer.

    function P2PKHOutTx( value , pubkey ) {
        let b = Buffer.makeOversizedBuffer();
        let o = 0;

        o=b.writeUInt32LE( value, o);               // Write the lower 32 bits of value in satoshis
        o=b.writeUInt32LE( 0 , o);                  // Full field is 64 bits, so write zeros in upper 32 bits.

        let outTxScript = P2PKHOutScript( pubkey );

        o=b.writeVarint( outTxScript.length , o );              // Out script len
        o=b.writeBuffer( outTxScript , o );

        return b.slice(0,o);
    }

    // Returns a 256 bit/32 byte buffer of the target in bitcoin LE format
    // Based on https://developer.bitcoin.org/reference/block_chain.html#target-nbits
    // Test here https://dlt-repo.net/bitcoin-target-calculator/
    // I think the string functions end up being more elegant than the typical math-based solutions, don't you?

    function nbits2target(nbits) {
        const significand = nbits & 0x00ffffff;
        const exponent = nbits >>> (8*3);

        // (all `*2` are becuase calcuations are in bytes, but in string 1 byte = 2 letter places)

        const fixed6SigString =  (significand.toString(16)).padStart( 3*2 , "0");
        //  a 3 digit (6 byte) hex string with a leading fixed point

        const paddedSigString = ("00").repeat(32) + fixed6SigString + ("00").repeat(32) ;
        // padded string has a fixed (hexa)decimal point after byte 32

        const expString = paddedSigString.slice( exponent*2, (32+exponent)*2);
        // Now we move the point to the right exp bytes

        return Buffer.fromHexString( expString );     // Put back in bitcoin LE format
    }

    /*
    Test cases:
    console.log( "target:" + nbits2target(0x01003456));     // 0x00
    console.log( "target:" + nbits2target(0x01123456));     // 0x12
    console.log( "target:" + nbits2target(0x02008000));     // 0x80
    console.log( "target:" + nbits2target(0x05009234));     // 0x92340000
    console.log( "target:" + nbits2target(0x04123456));     // 0x12345600

    console.log( "target:" + nbits2target(0x181bc330));
    console.log( "target:" + nbits2target(0x05009234));
    console.log( "target:" + nbits2target(0x04123456));
    */

    // Takes a  32 byte buffer with a target in bitcoin LE encoding and returns
    // the number of "free" nibbles where "free" means unconstrained as in "free variable".
    // So that means that the free least significant niblle in a hash can be any value and
    // the hash is still guaranteed to be less than the target. Any nibbles more significant
    // than these "free" once must be zero for a hash to win.

    // During actual game play we are generous and give the win to the player
    // in the case where the last (least significant) wheel (nibble) is not a hash symbol (zero nibble)
    // but the hash result is actually below the target.

    // Example:
    // if target is  "0000000000000000000b3ce90000000000000000000000000000000000000000",
    // then the hash "00000000000000000000ffffffffffffffffffffffffffffffffffffffffffff"
    // is less than the target and so is *any* hash with any niblles where the ff's are.

    function freeNibblesInTarget (target) {

        // String works well for this since 1 letter=1 nibble
        const targetHexString = target.toHexString();

        // We know that if a string of "f" digits is less than the hex of the target, then those digits can be anything
        // and still be less than the target since "f" is the highest digit.

        // Will terminate if target is all 'f' because we use less than in the compare and so all 'f' will not be less than
        // all 'f' (it will be equal to).

        let freeNibbleString = "f";

        while ( freeNibbleString.padStart( 64 , '0') < targetHexString  ) {
            freeNibbleString+='f';
        }

        return freeNibbleString.length-1;        // Since each char in the hex string is a nibble, we can just take the len

    }

    // Make a coinbase transaction.
    // extranonce is a buffer
    // blockheight is the heigh of the block this will be in (required by BIP-34)
    // public key is a buffer indicating where to send the coinbase reward to as P2PKH transaction.
    // Check here: https://live.blockcypher.com/btc/decodetx/

    function makeCoinbaseTX( extranoce , blockheight , publicKey ) {

        let b = Buffer.makeOversizedBuffer();
        let o = 0;

        o = b.writeUInt32LE(0x01, o);   // Version number. Currently 0x01 based on looking at recent coinbase transactions.

        // First inputs
        o = b.writeUInt8(0x01, o);    // Input count
        let inTx = coinbaseInputTx(blockheight,extranoce);
        o = b.writeBuffer(inTx, o);

        // Then outputs
        o = b.writeUInt8(0x01, o);     // Output count
        let outTx = P2PKHOutTx(5 * 1e8, publicKey);
        o = b.writeBuffer(outTx, o);

        o = b.writeUInt32LE(0x00000000, o);        // Locktime

        const coinbaseTransaction = b.slice(0, o);    // Trim buffer to actual size

        console.log( "coina:" + coinbaseTransaction.toHexString());

        return coinbaseTransaction;
    }

    // Make a new block header
    // Prevhash is a 32 byte LE buffer
    // merkleRoot is a 32 byte LE buffer
    // Timestamp is seconds seince midnight 1/1/1970 UTC
    // version is a 32 bit number
    // nbits is a 32 bit number
    // nonce is a 32 bit number

    // Returns a buffer

    function makeBlockHeader(version, prevHash, timestamp, nbits, merkleRoot, nonce) {

        // I know much of this could be precomputed for efficiency, but I am going for clarity here
        // and we only need to run faster than user can click.

        const b = Buffer.makeOversizedBuffer();
        let o=0;

        // https://developer.bitcoin.org/reference/block_chain.html

        // 02000000 ........................... Block version: 2
        //
        // b6ff0b1b1680a2862a30ca44d346d9e8
        // 910d334beb48ca0c0000000000000000 ... Hash of previous block's header
        // 9d10aa52ee949386ca9385695f04ede2
        // 70dda20810decd12bc9b048aaab31471 ... Merkle root
        //
        // 24d95a54 ........................... [Unix time][unix epoch time]: 1415239972
        // 30c31b18 ........................... Target: 0x1bc330 * 256**(0x18-3)
        // fe9f0864 ........................... Nonce

        // rawHeader = Buffer.from("02000000b6ff0b1b1680a2862a30ca44d346d9e8910d334beb48ca0c00000000000000009d10aa52ee949386ca9385695f04ede270dda20810decd12bc9b048aaab3147124d95a5430c31b18fe9f0864","hex");
        // bitcoinjs.crypto.hash256( rawHeader );   // Gives a hash ended in zeros, so we need to match above format.

        o=b.writeUInt32LE( version , o );           // I know it is not little endian HERE, but hey this is what you have to do to match the example!
        o=b.writeBuffer( prevHash , o);             // Should already be in little endian from the websocket
        o=b.writeBuffer( merkleRoot , o);           // Should  be in little endian with the zeros at the end (higher indexes)
        o=b.writeUInt32LE( timestamp , o);
        o=b.writeUInt32LE( nbits , o);
        o=b.writeUInt32LE( nonce , o)

        const block = b.slice(0, o);

        return block;

    }

    // Serialize into a buffer that can be hexified and passed to bitcoind via `submitblock`
    // Both inputs are buffers
    function serializeBlockWithTX( block , coinbaseTx ) {

        let serializedblockBuffer = Buffer.makeOversizedBuffer();
        o=0;

        o=serializedblockBuffer.writeBuffer( block , o );
        o=serializedblockBuffer.writeVarint( 0x01 , o );        // Transaction count
        o=serializedblockBuffer.writeBuffer( coinbaseTx , o );

        let serializedBlock = serializedblockBuffer.slice( 0 , o);

        console.log("serialized block:");
        console.log( serializedBlock.toString("hex") );

        return serializedBlock;
    }

    // Hand code prev hash for now...
    //block.prevHash = Buffer.from("367d631b6fd28a8cbf79513c20111463e777793a695c696ea8b2e9ef7aff65c8","hex").asReversed();


    /*
    // For testing force this block to be the one I see now so I can compare
    block.prevHash = Buffer.from("367d631b6fd28a8cbf79513c20111463e777793a695c696ea8b2e9ef7aff65c8","hex").asReversed();
    block.nonce = 1;
    block.merkleRoot = Buffer.from("c40a1e396b379545d12dcc6b26256d9173a9c6f27da6b3f3af04987749613b7d","hex").asReversed();
    block.timestamp = 1620111482;
    */
    // console.log("blockhash:");
    // console.log( blockhash.toString("hex") );
    //
    // console.log("block:");
    // console.log( block.toBuffer().toString("hex") );



</script>

<!--- WEBSOCKET STUFF --->

<script>

    // Process a message from the server that updates our prevHash [, target [, time since last block ]]
    // We will get a new prevHash anytime a new block in mined on the network
    // We will get a new target along with the prevHash at startup and every 2016th block when difficulty is adjusted
    // We should get the time since last block only on startup (the first message recieved)

    function processWebsocketData(b) {

        // All messages should at least have these fields, sent everytime there is a new block on the network.

        if (b.length>=4+4+32) {
            window.nowSecs     = b.readUInt32LE(0);     // Timestamp for current block in secs. We need to get from server since we can't know if browser clock is right and network will reject if off by >2 hours.
            window.blockheight = b.readUInt32LE(4);     // Height of next block. Needed only for coinbase because of BIP-34.
            window.prevHash    = b.slice( 8 , 32  );    // Remember this is in bitcoin LE encoding.
            console.log("Entering round #"+(blockheight+1)+" lastBlockTime="+Date(nowSecs)+" hash="+prevHash.toHexString() );
        }

        // We will also get these fields whenever difficulty changes and on the initial message after connecting.

        if (b.length>=4+4+32) {
            window.nbits = b.readUInt32LE( 4+4+32 );
            console.log("New nbits="+nbits.toString(16)+" so must find "+ freeNibblesInTarget( nbits2target( window.nbits ))+" hashes to win.");
        }

        // We get this only on initial connect. It lets us show the player how far into the current round we are...

        if (b.length>=4+4+32+4) {
            const delaySecs = b.readUInt16LE(4+4+32+4);       // When did the current round start (in ms). This is the only monotonic time I could find in all of javascript.
            window.currentRoundStartTime = performance.now() - (delaySecs * 1000);   // Convert secs to ms and offset from now
            console.log("Joining a round already in progress with "+delaySecs+" seconds currently on the clock.");
            // TODO: Add popup here.
            //alert("Joining a round already in progress with "+delaySecs+" seconds currently on the clock.");
        } else {
            window.currentRoundStartTime = performance.now();

        }

        // TODO: Refresh board

    }

    function submitBlockToServer( serializedBlock ) {
        // TODO
        ws.write( serializedBlock );
    }

    // TODO: Serve static files also https://stackoverflow.com/a/20920463/3152071

    // Open connection to server. Sadly this is hard coded becuase I could not figure how a good way to get express and ws running on the server at the same time.
    ws = new WebSocket( bitcoinWebsocketServer );
    ws.binaryType = "arraybuffer";
    deactivatePlay("Connecting to server")

    ws.onopen = () => {
        console.log('Websocket: Connection opened!');
        deactivatePlay("Coneected to server, waiting for data")
    }
    ws.onmessage = ({ data }) => {
        const b = Buffer.from( data );
        console.log('Websocket: received '+ b.length +' bytes');
        processWebsocketData(b);
        // TODO: Message that new round just started
        activatePlay();
    }

    ws.onerror = function(event) {
        deactivatePlay("Network error - refresh page to restart");
        console.error("WebSocket error observed:", event);
        // We depending on the fact that an onClose() will soon follow to alert the player
        // https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_client_applications#connection_errors
    };

    ws.onclose = function() {
        console.log('Websocket: Connection closed!' , event);
        ws = null;
        deactivatePlay("Connection lost - refresh page to restart.");
    }

</script>

</body>
</html>
<!doctype html>

<!---

    Dear skeptical reviewer,

    I am so glad you are here. It was not without great personal discomfort that I crafted Hash Hunt
    using only the most primitive and brutal tools available: Pure Javascript, CSS, and HTML.

    Why? I did it for you. So that you, gentle reader, could directly and independently verify that all
    Hash Hunt prize claims are absolutely and factually true. Code cannot lie, and so here is- naked and
    unminified for your thoughtful inspection.

    By the time you get to the end of this file, you will see that...

    1) It is possible for a user to pick a winning combination of numbers.
    2) Five bitcoin will be awarded to the first user to find a winning combination in each round.
    3) At no time will I ever touch the user's winnings or even have the opportunity to. The user
       will be able to claim their winnings directly using any bitcoin wallet that accepts a WIF formatted
       private key (all of them).

    Thank you for your time and participation in this experiment.

    -josh

--->

<html lang="en">
<head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- Nice google fonts  -->
    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link href="https://fonts.googleapis.com/css2?family=Girassol&family=Roboto&display=swap" rel="stylesheet">

    <title>Hash Hunt!</title>
</head>


<style>

    body {
        font-family: 'Roboto', sans-serif;
    }

    .kenocell {
        padding-top: 10px;
        padding-bottom: 10px;
        text-align: center;
        border-style: solid;
        border-width: 1px;
        cursor: pointer;
        user-select: none;
    }

    .kenocell_selected {
        background: #a52834;
    }

    .wheelscell {
        /*
        padding-top: 10px;
        padding-bottom: 10px;
        */
        text-align: center;
        border-style: solid;
        border-width: 1px;
        cursor: pointer;
        font-weight: bold;
        font-size: 1.5em;
    }

    @keyframes hash_cell_animation {
        0% {

        }

        100% {
            transform: scale(1.2);
            background: chartreuse;
        }
    }

    .wheels_cell_hash {
        animation-name: hash_cell_animation;
        animation-duration: 0.2s;
        animation-iteration-count: infinite;
        animation-direction: alternate;
    }

    table {
        table-layout: fixed;
    }

</style>
<body>
<div style="width: 100%; max-width: 600px; align-content: center;">

    <div style="display: block; width: 100%;">
        <table style="width: 100%;">
            <tr>
                <td>
                    <table style="display: inline;">
                        <tr><td><hr style="margin: 1px 0px 1px 0px; "></td></tr>
                        <tr><td><div style="box-sizing:border-box;"><span style="font-family: 'Girassol', serif ;font-size: large; padding: 5px; background: black; color:white; display:inline-block;">HASH HUNT</span></div></td></tr>
                        <tr><td><hr style="margin: 1px 0px 1px 0px; "></td></tr>
                    </table>
                </td>
                <td style="text-align: right; padding-right: 10px;">
                    <a href="info.html">more info</a><br><br>
                    <span id="status">Loading</span>
                </td>
            </tr>
        </table>
    </div>

    <div style="display: block; width: 100%;">
        <table id="wheelsTable" style="width: 100%;"></table>
    </div>

<!--    <div style="display: block; width: 100%;">-->
<!--        <td><hr></td>-->
<!--    </div>-->

    <div style="display: block; width: 100%;">
        <table id="kenotable" style="width: 100%;"></table>
    </div>
</div>

<!--- GLOBALS --->

<script>

    // Our wallet info, generated once on page load
    window.testmode = false;            // Test or Main. Set if URL contains "TESTMODE".
    window.keyPair;                     // User's keypair

    window.active = false;              // Are we currently playing a round? Set when first set of websocket data recieved.

    // Info on current round, based on data recieved over the websocket
    // TODO: Package this block stuff into an object to keep it neat
    window.version = 0x2268e004;        // (found emperically from recent blocks)
                                        // TODO: Get version from previous block over websock so we are good if it ever changes.

    window.nowSecs;                     // Time to used for current block. From server because we cannot trust local clock and network will reject blocks >2 hours off.
    window.nbits;                       // nbits for difficulty target from server.
    window.prevHash;                    // 32 byte hex string with previous block hash. Stored in bincoin LE order.
    window.blockheight;                 // UINT32 height of prev block. We need to put this in the coinbase as per BIP-34.

    window.currentRoundStartTime;       // When did the current round start by local clock in ms. Used for elapsed time display.

    window.bitcoinWebsocketServer;      // We connect here with a websocket to get live updates

    window.WHEEL_TABLE_COLS = 5;        // Must be an integer factor of 20 for now.
    window.WHEEL_TABLE_CELLS = 20;      // Total number of cells. Might need to incease if difficulty increases.
    window.wheelstablecells = [];       // Quick indexed access to the cells.

    window.KENO_TABLE_ROWS = 10;        // 80 bits of nonce should be enough
    window.KENO_TABLE_COLS = 8;
    window.kenocells = [];              // Quick indexed access to the cells.
</script>

<!-- PROGRAMMATICALLY BUILD THE WHEEL AND KENO TABLES --->

<script>
    let wheelstable = document.getElementById("wheelsTable");
    let cell_index = 0;
    let row_index = 0;
    while (cell_index < window.WHEEL_TABLE_CELLS) {
        let row = wheelstable.insertRow();
        for (let col_index = 0; col_index < window.WHEEL_TABLE_COLS; col_index++) {
            let cell = row.insertCell();
            window.wheelstablecells[cell_index] = cell;
            cell.classList.add("wheelscell");
            cell.appendChild(document.createTextNode("❓"));    // Question mark
            cell_index++;
        }
        row_index++;
    }

    let bit_index = 0;
    let kenotable = document.getElementById("kenotable");
    for (let row_index = 0; row_index < 10; row_index++) {
        let row = kenotable.insertRow();
        for (let col_index = 0; col_index < 8; col_index++) {
            let cell = row.insertCell();
            cell.classList.add("kenocell");
            let text = document.createTextNode(" " + (bit_index + 1));
            cell.appendChild(text);
            let tempvalue_of_bit_index = bit_index;
            cell.onmousedown = function () {
                kenoTableClickHandler(cell)
            };
            cell.onmouseenter = function (e) {
                if (e.buttons & 0x01) kenoTableClickHandler(cell)
            };
            kenocells[bit_index]=cell;
            bit_index++;
            //console.log("bi="+bit_index);
        }
    }
</script>

<!--- GET OUR MODE FROM URL --->

<script>
    const queryString = window.location.search;
    const urlParams = new URLSearchParams(queryString);

    if (urlParams.get('testmode') == "1") {
        window.testmode = true;
        console.log("Running in test mode based on URL parameter.");
        window.bitcoinWebsocketServer = 'ws://localhost';
        // TODO: Put real URLS here.
    } else {
        window.testmode = false;
        console.log("Running in real mode. Add `?testmode=1` to URL to use test mode.");
        window.bitcoinWebsocketServer = 'ws://localhost';
    }
</script>

<!-- REFRESH STATUS EVERY SECOND --->

<script>

    var statusElement = document.getElementById('status');     // Save in global so we don't have to look up every time

    function updateStatus() {

        if (window.active) {
            const elapsedTimeSecs = (performance.now()-window.roundStartTime)/1000;
            const h = Math.floor( elapsedTimeSecs / 3600 );
            const m = Math.floor( (elapsedTimeSecs - (h*3600)) / 60 );
            const s = Math.floor( (elapsedTimeSecs - (m*60)) );
            statusElement.innerText = "Elapsed time in this round:" + h.toString(10).padStart(2,'0')+":"+m.toString(10).padStart(2,'0')+":"+s.toString(10).padStart(2,'0');
        } else {
            statusElement.innerText = "NOT ACTIVE";        //https://stackoverflow.com/a/1322771/3152071
        }

    }

    // Update elapsed time counter once per second
    setInterval( updateStatus, 1000);

</script>


<script>

    // Set wheel w to the given value. 0=Hash, others=fruits
    function setWheel(w,v) {

        let cell = window.wheelstablecells[w];

        let t;

        if (v===0) {             // Winning wheel?
            t = "#";             // The magic hash
            cell.classList.add( "wheels_cell_hash");
        } else {
           t = String.fromCodePoint(127811+v );                // Fruits - https://www.w3schools.com/charsets/ref_emoji.asp#:~:text=127813
           cell.classList.remove( "wheels_cell_hash");
        }

        cell.innerHTML = t;
        //console.log( "wheel="+w+" t="+t + "v=" +v);
    }

    // Set all the wheels according to the leading bytes of v
    // v is a string of hex digits at least `difficulty` in length
    function setwheels(v) {
        for( let i=0; i<window.WHEEL_TABLE_CELLS;i++ ) {
            setWheel(i, Number.parseInt( v[i] , 16  ) );
        }

    }

    function toBin( b ) {
        let s="";
        for( let i =0 ; i< bits.length; i++ ) {
            s = ( b[i] ? "1":"0" ) + s;
        }
        return s;
    }

    // Updates the wheels in the DOM and then checks for winner
    // In case of a winning pattern, sumbits and redirects to winner instructions page

    function updateWheels() {

        console.log("in updatewheels");

        // First calculate the nonce bits from the keno table selections
        const kenoBitCount = window.KENO_TABLE_COLS * window.KENO_TABLE_ROWS;
        let kenoBitsBuffer = bitcoinjs.buffer.Buffer( Math.ceil( kenoBitCount/8) );     // 8 bits per byte. JS should really have a bit array. :/

        for( let i=0; i<kenoBitCount; i++) {
            if (window.kenocells[i].classList.contains("kenocell_selected")) {
                let byte_index = Math.floor( i/8 );
                let bit_index = i % 8;
                kenoBitsBuffer[byte_index]  |= ( 1 << bit_index );
            }
        }

        // Next generate a block with the keno bits as the extranonce

        // console.log("bhh="+window.blockheight);
        //
        //
        // const coinbaseTX =  makeCoinbaseTX( kenoBitsBuffer , window.blockheight , window.keyPair.publicKey );
        // const merkleRoot =  bitcoinjs.crypto.sha256( bitcoinjs.crypto.sha256( coinbaseTX ) );
        //
        // // We have 80 bits of nonce, so we put them into the extranonce and use 0 for the block header nonce.
        // // TODO: Have a webworker try all  nonces in the backround between clicks... or would that be karmic cheating?
        //
        // const block = makeBlock( window.version , window.prevHash ,  window.nowSecs , window.nbits , merkleRoot , 0x00000000 );
        //
        // // Now check to see if we have a winner!
        //
        // const blockHash = block.getHash();


        // TEST MINER BELOW
        window.prevHash = bitcoinjs.buffer.Buffer.from("0000a23341f706b1c255456d432e6bd002e6a829fe209e47e2751317cb7e0edc").asReversed();
        window.nowSecs = 1620115082;
        window.nbits = 0x207fffff;
        window.blockheight = 5;

        let nonce =0;

        let blockhash = "";

        do {

            const coinbaseTX =  makeCoinbaseTX( kenoBitsBuffer , window.blockheight , window.keyPair.publicKey );
            const merkleRoot =  bitcoinjs.crypto.sha256( bitcoinjs.crypto.sha256( coinbaseTX ) );

            // We have 80 bits of nonce, so we put them into the extranonce and use 0 for the block header nonce.
            // TODO: Have a webworker try all  nonces in the backround between clicks... or would that be karmic cheating?

            const block = makeBlock( window.version , window.prevHash ,  window.nowSecs , window.nbits , merkleRoot , nonce);

            // Now check to see if we have a winner!

            blockHash = bitcoinjs.crypto.hash256(block);

            console.log( "nonce= "+nonce+" blockhash:" + blockhash.toString("hex") );


            nonce++;

        } while ( blockHash[31]!=0 || blockHash[30] !=0 ||  blockHash[29]!=0 || blockHash[28] !=0  );

        console.log( "blockhash:" + blockhash.toString("hex") );

        for( let i=0; i<WHEEL_TABLE_CELLS; i++) {


        }
        //TODO: Fill in
        //
        // var out = bitcoinjs.crypto.sha256(bitcoinjs.buffer.Buffer(hasstr)).toString("hex");
        // //var out = Sha256.hash(Sha256.hash( hasstr));
        // //console.log( "hex="+ hasstr +" out="+out);
        //
        // setwheels(out);
    }

    // Clear all selections from kenotable and start fresh.

    function clearKenoTable() {
        for (let cell of kenocells) {
            cell.classList.remove("kenocell_selected");
        }
    }

    // Toggle the cell (button) selected state

    function kenoTableClickHandler(cell) {
        console.log("kenoclick");

        if (cell.classList.contains( "kenocell_selected" )) {
            cell.classList.remove("kenocell_selected");
        } else {
            cell.classList.add("kenocell_selected");
        }

        updateWheels();
    }

</script>

<!-- BITCOIN STUFF -->

<!--
    This is a Browserfy'ed version of the popular bitcoinjs package.
    To verify it is trustworthy for yourself, check out /js/bitcoinjs.MD
    We only use it to generate the public ECSDA key and do some formatting.
    Sorry, I could not bring myself to write this stuff in Javascript. If
    you know a clean alternative I can use, please suggest it. I do not
    want to use the subtlecrypto stuff because it has the absurd requirement
    that it will only generate keys when loaded over SSL. This seems like a
    deep misunderstanding of crypto. Please correct me if I am wrong.
-->

<script src="js/bitcoinjs.min.js">
</script>

<!-- GENERATE OUR BITCOIN PRIZE REDEMTION ADDRESS ONCE ON PAGELOAD. READS TESTMODE, SAVES KEYPAIR. --->

<script>

    function getAddressFromKeyPair( kp ) {
        bitcoinjs.payments.p2pkh({ pubkey: kp.publicKey ,  network  }).address;
    }

    let network;

    if (testmode) {
        network = bitcoinjs.networks.testnet;
    } else {
        network = bitcoinjs.networks.main;
    }

    window.keyPair = bitcoinjs.ECPair.makeRandom( {network: network} );

    console.log( "Prize redemption key (do not tell to ANYONE or they can claim your prizes!):"+ window.keyPair.toWIF());
    // You can test WIFs at http://gobittest.appspot.com/PrivateKey or import them into bitcoin-core
    // with the commmand "importprivkey [key] [name for key in wallet]"

</script>

<!--- GENERATE A BLOCK. READS KENOBITS, KEYPAIR, KENOBITS, ROUNDSTARTTIME, TARGTEHEX, AND PREVHASH --->
<!--- UPDATES WHEELS TABLE AND SUBMITS BLOCK IF WINNING SOLUTION FOUND -->

<script>

    // Shortcut to make an oversized buffer
    function makeOversizedBuffer()
    {
        return bitcoinjs.buffer.Buffer(256);
    }

    // How can the API not come with this function?!
    bitcoinjs.buffer.Buffer.prototype.writeBuffer = function ( b , o  ) {
        return o+b.copy( this , o  );
    }

    // How can the API not come with this function?!
    bitcoinjs.buffer.Buffer.prototype.writeUInt24LE = function ( x , o  ) {

        let b2 = ((x >> 16) & 0xff);
        let b1 = ((x >>  8) & 0xff);
        let b0 = ((x >>  0) & 0xff);

        o=this.writeUInt8( b0 , o );
        o=this.writeUInt8( b1 , o );
        o=this.writeUInt8( b2 , o );

        return o;
    }

    // Write a bitcoin varint type
    // Defined here https://developer.bitcoin.org/reference/transactions.html#compactsize-unsigned-integers
    bitcoinjs.buffer.Buffer.prototype.writeVarint = function ( x , o  ) {

        if ( x <= 252 ) {
            o = this.writeUInt8(x, o);             // Small numbers are themselves
        } else if (x <=0xffff) {
            o = this.writeUInt8(0xfd, o);             // Prefix
            o = this.writeUInt16LE(x, o);             // Prefix
        } else if ( x<=  0xffffffff ) {
            o = this.writeUInt8(0xfe, o);             // Prefix
            o = this.writeUInt32LE(x, o);             // Prefix
        } else if ( x<=  0xffffffffffff ) {
            o = this.writeUInt8(0xff, o);             // Prefix
            o = this.writeUInt24LE(x, o);             // Prefix
            o = this.writeUInt8( 0, o);               // We only support up to 24 bits, fill top with 0
        } else {
            console.error( "Number too big in writeVarint:" + x );
        }
        return o;
    }

    // How can the API not come with this function?!
    bitcoinjs.buffer.Buffer.prototype.fillByte = function ( b , c , o  ) {
        while (c) {
            o=this.writeUInt8( b , o );
            c--;
        }
        return o;
    }

    // How can the API not come with this function?!
    bitcoinjs.buffer.Buffer.prototype.asReversed = function () {
        let r = bitcoinjs.buffer.Buffer( this.length );

        for( let s=0; s< this.length ; s++ ) {

            r[(this.length-s)-1] = this[s];
        }

        return r;
    }


    // Now lets try adding a coinbase transaction to the block
    // Here is an empty block we can use as a template:
    // d8025d52f6d10559f60207f4f9db2545f1935ef69a5b418e9b2ae6e711b654e6
    // It has one transaction:
    // d8025d52f6d10559f60207f4f9db2545f1935ef69a5b418e9b2ae6e711b654e6
    // As raw Hex:
    // https://blockchain.info/tx/d8025d52f6d10559f60207f4f9db2545f1935ef69a5b418e9b2ae6e711b654e6?format=hex
    // 010000000001010000000000000000000000000000000000000000000000000000000000000000ffffffff5403e8650a1b4d696e656420627920416e74506f6f6c37363978002902b7c70781fabe6d6d83410bf4ea571acde5acecff1587f39ff6b027f422575e933acf1043d0ccee3002000000000000009af000001a070000ffffffff0440be4025000000001976a91411dbe48cc6b617f9c6adaf4d9ed5f625b1c7cb5988ac0000000000000000266a24aa21a9ede2f61c3f71d1defd3fa999dfa36953755c690689799962b48bebd836974e8cf90000000000000000266a24b9e11b6d45d19962c0f444142e898f64a94b73324896afa4adfe794cf63e0f3cd521f6df00000000000000002b6a2952534b424c4f434b3a1ba6a546d2bcb116f744b51c4749d02e4fcd6ceb2d158fb5c14b3828003293ec0120000000000000000000000000000000000000000000000000000000000000000000000000
    // 01000000: Version 1
    // 00 : Input count?
    // 01010000000000000000000000000000000000000000000000000000000000000000ffffffff5403e8650a1b4d696e656420627920416e74506f6f6c37363978002902b7c70781fabe6d6d83410bf4ea571acde5acecff1587f39ff6b027f422575e933acf1043d0ccee3002000000000000009af000001a070000ffffffff0440be4025000000001976a91411dbe48cc6b617f9c6adaf4d9ed5f625b1c7cb5988ac0000000000000000266a24aa21a9ede2f61c3f71d1defd3fa999dfa36953755c690689799962b48bebd836974e8cf90000000000000000266a24b9e11b6d45d19962c0f444142e898f64a94b73324896afa4adfe794cf63e0f3cd521f6df00000000000000002b6a2952534b424c4f434b3a1ba6a546d2bcb116f744b51c4749d02e4fcd6ceb2d158fb5c14b3828003293ec0120000000000000000000000000000000000000000000000000000000000000000000000000
    //

    // https://medium.com/@aniketdivekar/bitcoin-create-sign-and-push-transaction-2ea877c08ab4


    // Push a value on the stack using the most efficient OP code
    function pushValueScriptOps( d ) {
        let b = bitcoinjs.buffer.Buffer( 256 );     // This is lazy, but I am bad at counting
        let o=0;

        // All the op codes 1-75 mean "push x bytes on stack"

        if ( d < (1<<8) ) {
            o=b.writeUInt8( 0x01 , o );                             // 1 byte of data OP_CODE
            o=b.writeUInt8(    d , o );
        } else if ( d < (1<<16) ) {
            o=b.writeUInt8( 0x02 , o );                             // 2 byte of data OP_CODE
            o=b.writeUInt16LE(  d , o );
        } else if ( d < (1<<24) ) {
            o=b.writeUInt8( 0x03 , o );                             // 3 byte of data OP_CODE
            o=b.writeUInt24LE(   d , o );
        } else if ( d.toString(16).length <=8 ) {                  // The only way I can think of to check if value fits in 32 bit int in Javascript?
            o = b.writeUInt8(0x04, o);                             // 4 byte of data OP_CODE
            o = b.writeUInt32LE( d, o);
        } else {
            console.error( "Value to big in pushValueScript "+ d );
        }

        return b.slice(0,o);
    }

    // Push a buffer on the stack using the most efficient OP code
    function pushBufferScriptOps( s ) {
        let b = bitcoinjs.buffer.Buffer( 256 );     // This is lazy, but I am bad at counting
        let o=0;

        // All the op codes 1-75 mean "push x bytes on stack"
        if (s.length <= 75 ) {
            o = b.writeUInt8(s.length, o);                             // 1 byte of data OP_CODE
        } else if (s.length < (1<<8) ) {
            o=b.writeUInt8(  bitcoinjs.opcodes.OP_PUSHDATA1 , o );
            o=b.writeUInt8( s.length , o );
        } else if ( s.length < (1<<16) ) {
            o=b.writeUInt8( bitcoinjs.opcodes.OP_PUSHDATA2  , o );                             // 2 byte of data OP_CODE
            o=b.writeUInt16LE(  s.length , o );
        } else if ( s.length < (1<<24) ) {
            o=b.writeUInt8( bitcoinjs.opcodes.OP_PUSHDATA3   , o );                             // 3 byte of data OP_CODE
            o=b.writeUInt24LE(   s.length , o );
        } else if ( s.length.toString(16).length <= 8 ) {                                       // I can not think of a better way to do this in javascript, can you?
            o = b.writeUInt8( bitcoinjs.opcodes.OP_PUSHDATA4  , o);                             // 4 byte of data OP_CODE
            o = b.writeUInt32LE( s.length, o);
        } else {
            console.error( "Value to big in pushValueScript "+ d );
        }

        // Write the actual data itself
        o=b.writeBuffer( s , o );

        return b.slice(0,o);
    }


    // Let's build a raw coinbase transaction from scratch since I can not figure out how to do it in bitcoinjs

    // Returns a buffer with the BIP-34 "push blockheight" that must be at the begining of every coinbase unlock script

    function coinbaseUnlockScript( blockheight , extraNonce ) {
        let b = makeOversizedBuffer();     // This is lazy, but I am bad at counting
        let o=0;

        // We need to push the block number on the stack as per BIP-0034
        let pushBlockheightOps = pushValueScriptOps(blockheight);
        o=b.writeBuffer(pushBlockheightOps,o);

        console.log("script:" + blockheight );
        console.log( b.slice(0,o).toString("hex"));

        // Here we get to stick in a little message in the coinbase
        o=b.writeBuffer( bitcoinjs.buffer.Buffer.from("/Play Hashhunt.josh.com/") , o );
        console.log("with mesage:" + blockheight );
        o=b.writeBuffer( extraNonce , o );         // These nonce bits will hopefuly percolate into a nice merkle hash and then into a nice block hash

        console.log( b.slice(0,o).toString("hex"));

        return b.slice(0,o);            // Trim buffer to actual size
    }

    // Creates a coinbase input transaction. Takes blockheight as a num and extranonce as buffer. Returns a buffer.
    function coinbaseInputTx(blockheight,extranonce) {
        let b = makeOversizedBuffer();
        let o=0;
        o=b.fillByte( 0x00 , 32 , o  );      // source hash - null by convention
        o=b.writeUInt32LE(0xffffffff,o);     // source index - -1 by convention

        // We need to push the block number on the stack as per BIP-0034
        let coinbasescript= coinbaseUnlockScript( blockheight , extranonce );

        o=b.writeVarint( coinbasescript.length , o );
        o=b.writeBuffer( coinbasescript , o );

        o=b.writeUInt32LE( 0xffffffff ,o);    // Sequence number - seems to always be -1

        console.log("coinbase:");
        console.log("height:" + blockheight );
        console.log( b.slice(0,o).toString("hex"));

        return b.slice(0,o);                // Trim buffer to actual size
    }

    // Creates a single P2PK locking script
    // Takes a buffer with the public key, returns a buffer
    function outScript( pubkey ) {
        let b = makeOversizedBuffer();
        let o = 0;
        // Simplest lock script is to push a publick key and the OP_CHECK sig
        let pushPKops = pushBufferScriptOps( pubkey );
        o=b.writeBuffer( pushPKops  , o );
        o=b.writeUInt8(  bitcoinjs.opcodes.OP_CHECKSIG , o );
        return b.slice(0,o);  // Trim buffer to actual size
    }

    // Create a normal P2PK tx
    // Value is number of satoshis. Must be < 2^32.
    // Pubkey is a buffer with the public key.
    // Returns a buffer.
    function P2PKOut( value , pubkey ) {
        let b = makeOversizedBuffer();
        let o = 0;
        o=b.writeUInt32LE(value , o);           // Write the lower 32 bits of value we are sending.
        o=b.writeUInt32LE( 0 , o);              // Full field is 64 bits, so write zeros in upper 32 bits.
        let outscriptBuffer = outScript(pubkey);
        o=b.writeUInt8( outscriptBuffer.length , o);
        o=b.writeBuffer( outscriptBuffer , o );
        return b.slice(0,o);
    }

    // Create a standard  P2PKH lock script
    // Pubkey is a buffer public key
    // Returns a buffer.
    function P2PKHOutScript( pubkey ) {
        let b = makeOversizedBuffer();     // This is lazy, but I am bad at counting
        let o = 0;
        // Below is the standard P2PKH script: OP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG
        // Helpful for debugging this.. https://siminchen.github.io/bitcoinIDE/build/editor.html
        // (took 1 hour to figure out that pubkeyhash.len should have been pubkeyhash.length. I hate JS.)

        o=b.writeUInt8( bitcoinjs.opcodes.OP_DUP , o );
        o=b.writeUInt8( bitcoinjs.opcodes.OP_HASH160 , o );

        let pubkeyhash = bitcoinjs.crypto.hash160( pubkey );

        let pushPubKeyOps = pushBufferScriptOps( pubkeyhash );
        o=b.writeBuffer( pushPubKeyOps , o );

        o=b.writeUInt8( bitcoinjs.opcodes.OP_EQUALVERIFY , o );
        o=b.writeUInt8( bitcoinjs.opcodes.OP_CHECKSIG , o );

        return b.slice(0,o);
    }

    // Create a normal P2PKH tx
    // value is satoshis
    // Pubkey is a buffer public key
    // Returns a buffer.

    function P2PKHOutTx( value , pubkey ) {
        let b = makeOversizedBuffer();
        let o = 0;

        o=b.writeUInt32LE( value, o);               // Write the lower 32 bits of value in satoshis
        o=b.writeUInt32LE( 0 , o);                  // Full field is 64 bits, so write zeros in upper 32 bits.

        console.log("value:")
        console.log( value.toString( 16) );

        let outTxScript = P2PKHOutScript( pubkey );

        console.log("outTxScript:")
        console.log( outTxScript.toString("hex") );

        o=b.writeVarint( outTxScript.length , o );              // Out script len
        o=b.writeBuffer( outTxScript , o );

        return b.slice(0,o);
    }

    // Returns a 256 bit/32 byte buffer of the target
    // Based on https://developer.bitcoin.org/reference/block_chain.html#target-nbits
    // I think the string functions end up being more elegant than the typical math-based solutions, don't you?

    function nbits2target(nbits) {
        const significand = nbits & 0x00ffffff;
        const exponent = nbits >>> (8*3);
        const targetStr =  (((significand.toString(16)).padStart( 6 , '0')).padEnd( exponent*2 , '0')).padStart( 32 * 2 , '0');      // *2 because two chars per byte in a hex string
        return bitcoinjs.buffer.Buffer.from( targetStr, "hex");
    }

    /*
    console.log( "target:" + nbits2target(0x181bc330));
    console.log( "target:" + nbits2target(0x05009234));
    console.log( "target:" + nbits2target(0x04123456));
    */

    // Takes a  32 byte buffer with a target in bitcoin LE encoding and returns
    // the number of hash wheels needed to win. (This is really the minimum number of leading
    // 0 nibbles to be sure we are below the target.
    // During actual game play we are generous and give the win to the player
    // in the case where the last wheel is not a hash wheel but the hash result is actually below the target.)

    function target2hashcount( b ) {

        // Remember bitcoin buffers are lowest bit first!
        function getBitofBuffer( buffer , bit ) {
            const byte = Math.floor( bit / 8 );
            const subbit = bit % 8;

            if ( ( (buffer[byte] >> subbit) & 0x01 ) == 0x01 ) {
                return true;
            } else {
                return false;
            }
        }

        let zerobitcount=0;

        while ( getBitofBuffer( b , zerobitcount ) == false ) {
            zerobitcount++;
        }

        // Zerobitcoin now holds the number of leading 0 bits in the buffer
        console.log("zero count:"+zerobitcount);

        let hashcount = Math.ceil( zerobitcount  / 4);        //Count zero nibbles needed, rounding up to catch if the final one is partially zero.

        return hashcount;
    }

    // Make a coinbase transaction.
    // extranonce is a buffer
    // blockheight is the heigh of the block this will be in (BIP-34)
    // public key is a buffer to send the coinbase reward to as P2PKH transaction.

    function makeCoinbaseTX( extranoce , blockheight , publicKey ) {
        console.log("bh="+blockheight);

        let b = makeOversizedBuffer();
        let o = 0;

        o = b.writeUInt32LE(0x01, o);   // Version number. Currently 0x01 based on looking at recent coinbase transactions.

        // First inputs
        o = b.writeUInt8(0x01, o);    // Input count
        let inTx = coinbaseInputTx(blockheight,extranoce);
        o = b.writeBuffer(inTx, o);

        console.log("after cb:")
        console.log(b.slice(0, o).toString("hex"));

        // Then outputs
        o = b.writeUInt8(0x01, o);     // Output count
        let outTx = P2PKHOutTx(5 * 1e8, publicKey);
        o = b.writeBuffer(outTx, o);

        o = b.writeUInt32LE(0x00000000, o);        // Locktime

        var coinbaseTransaction = b.slice(0, o);    // Trim buffer to actual size

        console.log("TX:");
        console.log(coinbaseTransaction.toString("hex"));

        return coinbaseTransaction;
    }


    // Make a new block with a single coinbase transaction
    // extranonce is a buffer
    // blockheight is the heigh of the block this will be in (BIP-34)
    // Timestamp is seconds seince midnight 1/1/1970 UTC
    // nbits is a number
    // coinbaseTX is the coinbase transaction in a buffer
    // nonce is 32 bit number

    // Returns a buffer

    function makeBlock( version , prevHash , timestamp , nbits , merkleRoot , nonce ) {

        // I know much of this could be precomputed for efficiency, but I am going for clarity here
        // and we only need to run faster than user can click.

        const b = makeOversizedBuffer();
        let o=0;

        // https://developer.bitcoin.org/reference/block_chain.html

        // 02000000 ........................... Block version: 2
        //
        // b6ff0b1b1680a2862a30ca44d346d9e8
        // 910d334beb48ca0c0000000000000000 ... Hash of previous block's header
        // 9d10aa52ee949386ca9385695f04ede2
        // 70dda20810decd12bc9b048aaab31471 ... Merkle root
        //
        // 24d95a54 ........................... [Unix time][unix epoch time]: 1415239972
        // 30c31b18 ........................... Target: 0x1bc330 * 256**(0x18-3)
        // fe9f0864 ........................... Nonce

        // rawHeader = bitcoinjs.buffer.Buffer.from("02000000b6ff0b1b1680a2862a30ca44d346d9e8910d334beb48ca0c00000000000000009d10aa52ee949386ca9385695f04ede270dda20810decd12bc9b048aaab3147124d95a5430c31b18fe9f0864","hex");
        // bitcoinjs.crypto.hash256( rawHeader );   // Gives a hash ended in zeros, so we need to match above format.

        o=b.writeUInt32LE( version , o );           // I know it is not little endian HERE, but hey this is what you have to do to match the example!
        o=b.writeBuffer( prevHash , o);             // Should already be in little endian from the websocket
        o=b.writeBuffer( merkleRoot , o);           // Should  be in little endian with the zeros at the end (higher indexes)
        o=b.writeUInt32LE( timestamp , o);
        o=b.writeUInt32LE( nbits , o);
        o=b.writeUInt32LE( nonce , o)

        const block = b.slice(0, o);

        return block;

    }

    // Serialize into a buffer that can be hexified and passed to bitcoind via `submitblock`
    // Both inputs are buffers
    function serializeBlockWithTX( block , coinbaseTX ) {

        let serializedblockBuffer = makeOversizedBuffer();
        o=0;

        o=serializedblockBuffer.writeBuffer( block , o );
        o=serializedblockBuffer.writeVarint( 0x01 , o );        // Transaction count
        o=serializedblockBuffer.writeBuffer( coinbaseTX , o );

        let serializedBlock = serializedblockBuffer.slice( 0 , o);

        console.log("serialized block:");
        console.log( serializedBlock.toString("hex") );

        return serializedBlock;
    }

    // Hand code prev hash for now...
    //block.prevHash = bitcoinjs.buffer.Buffer.from("367d631b6fd28a8cbf79513c20111463e777793a695c696ea8b2e9ef7aff65c8","hex").asReversed();


    /*
    // For testing force this block to be the one I see now so I can compare
    block.prevHash = bitcoinjs.buffer.Buffer.from("367d631b6fd28a8cbf79513c20111463e777793a695c696ea8b2e9ef7aff65c8","hex").asReversed();
    block.nonce = 1;
    block.merkleRoot = bitcoinjs.buffer.Buffer.from("c40a1e396b379545d12dcc6b26256d9173a9c6f27da6b3f3af04987749613b7d","hex").asReversed();
    block.timestamp = 1620111482;
    */
    // console.log("blockhash:");
    // console.log( blockhash.toString("hex") );
    //
    // console.log("block:");
    // console.log( block.toBuffer().toString("hex") );



</script>

<!--- WEBSOCKET STUFF --->

<script>

    // Process a message from the server that updates our prevHash [, target [, time since last block ]]
    // We will get a new prevHash anytime a new block in mined on the network
    // We will get a new target along with the prevHash at startup and every 2016th block when difficulty is adjusted
    // We should get the time since last block only on startup (the first message recieved)

    function processWebsocketData(b) {

        // All messages should at least have these fields, sent everytime there is a new block on the network.

        if (b.length>=4+4+32) {
            window.nowSecs         = b.readUInt32LE(0);     // Timestamp for current block in secs. We need to get from server since we can't know if browser clock is right and network will reject if off by >2 hours.
            window.blockheight = b.readUInt32LE(4);         // Height of next block. Needed only for coinbase because of BIP-34.
            window.prevHash        = b.slice( 8 , 32  );    // Remember this is in bitcoin LE encoding.
            console.log("Entering round #"+blockheight+1);
        }

        // We will also get these fields whenever difficulty changes and on the initial message after connecting.

        if (b.length>=4+4+32+4) {
            window.nbits = b.readUInt32LE( 32 );
            console.log("Must find "+ target2hashcount( nbits2target( window.nbits ))+" hashes to win.");
        }

        if (b.length>=4+4+32+4+4) {
            const delaySecs = b.readUInt32LE(36);       // When did the current round start (in ms). This is the only monotonic time I could find in all of javascript.
            window.currentRoundStartTime = performance.now() - (delaySecs * 1000);   // Convert secs to ms and offset from now
            console.log("Joining a round already in progress with "+delaySecs+" seconds currently on the clock.");
            // TODO: Add popup here.
            //alert("Joining a round already in progress with "+delaySecs+" seconds currently on the clock.");
        } else {
            window.currentRoundStartTime = performance.now();

        }

        // TODO: Refresh board

    }

    // Open connection to server. Sadly this is hard coded becuase I could not figure how a good way to get express and ws running on the server at the same time.
    ws = new WebSocket( bitcoinWebsocketServer );
    ws.binaryType = "arraybuffer";

    ws.onopen = () => {
        console.log('Websocket: Connection opened!');
    }
    ws.onmessage = ({ data }) => {
        const b = bitcoinjs.buffer.Buffer.from( data );
        console.log('Websocket: received '+ b.length +'bytes');
        processWebsocketData(b);
        ws.send( bitcoinjs.buffer.Buffer.from("49b024a553abf2a23d41ea04e2d64d4e5a33039c86e739299ec13df10e9e7859","hex").reverse() );
    }
    ws.onclose = function() {
        console.log('Websocket: Connection closed!');
        ws = null;
    }

</script>

</body>
</html>
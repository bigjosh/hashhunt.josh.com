<!doctype html>

<!---

    Dear skeptical reviewer,

    I am so glad you are here. It was not without great personal discomfort that I crafted Hash Hunt
    using only the most primitive and brutal tools available: Pure Javascript, CSS, and HTML.

    Why? I did it for you. So that you, gentle reader, could directly and independently verify that all
    my claims are absolutely and factually true. Code cannot lie and so here is, naked and unminified
    for your thoughtful inspection.

    By the time you get to the end of this file, you will see that...

    1) It is possible for a user to pick a winning combination of numbers.
    2) Five bitcoin  will be awarded to the first user to find a winning combination in each round.
    3) At no time will I ever touch the user's winnings or even have the opportunity to. The user
       will be able to claim their winnings directly using any bitcoin wallet that accepts a WIF formatted
       private key (all of them).

    These are factual assertions, and I am certain that you will find nothing to contradict them.

    We are all readers and writers of code here. We speak in languages with strict definitions and specifications.
    We are committed to the goal of representing ideas and processes precisely and correctly. Some live in a
    qualitative world of blurry boarders and uncertain distinctions. We do not. We know that zero is zero, and
    any other number, no matter how small, is still not zero. Zero is a singularity, defined by its not being
    any other number.

    With this in mind, I will ask you to remember that there is a categorical difference between "non-zero chance"
    and "zero chance". While there are levels of probability that you (and I) might consider so small as to be de
    minimis, there are many who do not share our opinion. If you doubt this, try computing the expected value of a
    Powerball ticket. So I respectfully ask that you please do try to avoid making the error of conflating "highly
    unlikely" with "impossible". And always be ready to update your priors when presented with new evidence.

    And, finally, remember that there is also a non-zero chance that our intuitions about luck and probability in
    this context are wrong!

    You are an important part of this grand experiment. Thank you for your participation.

    -josh

--->

<html lang="en">
<head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- Favicon codes generated by https://realfavicongenerator.net/ -->
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">

    <!-- Nice google fonts  -->
    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link href="https://fonts.googleapis.com/css2?family=Girassol&family=Roboto&display=swap" rel="stylesheet">

    <title>Hash Hunt!</title>
</head>


<style>

    body {
        font-family: 'Roboto', sans-serif;;
    }

    .kenocell {
        padding: 20px 25px;
        margin: 15px;
        text-align: center;
        border-style: solid;
        border-width: 1px;
        cursor: pointer;
        user-select: none;
    }

    .kenocell_selected {
        background: #a52834;
    }

    .wheelscell {
        padding: 10px 10px;
        text-align: center;
        border-style: solid;
        border-width: 1px;
        cursor: pointer;
        font-weight: bold;
        font-size: 1.5em;
    }

    @keyframes hash_cell_animation {
        0% {

        }

        100% {
            transform: scale(1.2);
            background: chartreuse;
        }
    }

    .wheels_cell_hash {
        animation-name: hash_cell_animation;
        animation-duration: 0.2s;
        animation-iteration-count: infinite;
        animation-direction: alternate;
    }

</style>
<body>
<table>
    <tr><td><hr style="margin: 1px 0px 1px 0px; "></td></tr>
    <tr><td><div style="box-sizing:border-box;"><span style="font-family: 'Girassol', serif ;font-size: xx-large; padding: 10px; background: black; color:white; display:inline-block;">HASH HUNT</span></div></td></tr>
    <tr><td><hr style="margin: 1px 0px 1px 0px; "></td></tr>
</table>
<ul>
    <li>Click numbers to toggle.</li>
    <li>Make all the reels come up hashes.</li>
    <li>First to find winning pattern gets 5 bitcoin.</li>
    <li>Round continues until winning pattern is found.</li>
    <li>New patterns in each round.</li>
</ul>

<table>
    <tr style="width: 100%;"><td style="width: 100%;">
        <table id="wheelsTable" style="width: 100%;"></table>
    </td></tr>

    <tr><td>

    <!---   Debug info on the bits and the hash
        <div id="in" style="font-family: 'Courier New',monospace" >NOT SET YET</div>
        <div id="out" style="font-family: 'Courier New',monospace">NOT SET YET</div>
    --->
    </td></tr>

    <tr><td>
        <table id="kenotable"></table>
    </td></tr>
</table>

<!-- Import a clean, no-dependency sha256 function -->
<!-- From https://www.movable-type.co.uk/scripts/sha256.html#src-code -->
<!-- Noticeably faster then the bitcoinjs one. -->
<!-- Note I removed the `export` line at the end to avoid modules. -->
<script  src="js/sha256.js" ></script>

<script>

    // Number of leading hex 0's we need to get to win
    var difficulty = 20;

    // Quick access to the textContent of the cells.
    var wheelstablecells = [];

    // Set wheel w to the given value. 0=Bitcoin, others=fruits
    function setWheel(w,v) {

        let cell = wheelstablecells[w];

        let t;

        if (v===0) {             // Winning wheel?
            t = "#";             // The magic hash
            cell.classList.add( "wheels_cell_hash");
        } else {
           t =  "&#" + (127811+v) +";";  // Fruits
           cell.classList.remove( "wheels_cell_hash");
        }

        cell.innerHTML = t;
        //console.log( "wheel="+w+" t="+t + "v=" +v);
    }

    // Set all the wheels according to the leading bytes of v
    // v is a string of hex digits at least `difficulty` in length
    function setwheels(v) {
        for( let i=0; i<difficulty;i++ ) {
            setWheel(i, Number.parseInt( v[i] , 16  ) );
        }

    }

    // We want this to be a global so we use `var` on purpose
    var bits=[];

    function toBin( b ) {
        let s="";
        for( let i =0 ; i< bits.length; i++ ) {
            s = ( b[i] ? "1":"0" ) + s;
        }
        return s;
    }

    function clickHandler(cell,bit) {

        console.log("clickhandler cell="+cell+" bit="+bit+" bits="+ toBin(bits) );

        if (bits[bit]) {
            cell.classList.remove("kenocell_selected");
            bits[bit]=false;
        } else {
            cell.classList.add("kenocell_selected");
            bits [bit]=true;
        }
        var hasstr = "X"+toBin(bits)
        //hasstr = "abc";

        var out = bitcoinjs.crypto.sha256( bitcoinjs.buffer.Buffer( hasstr )).toString("hex");
        //var out = Sha256.hash(Sha256.hash( hasstr));
        //console.log( "hex="+ hasstr +" out="+out);

        setwheels(out);
    }

    let wheelstable = document.getElementById("wheelsTable");
    let cell_index=0;
    for(let row_index=0; row_index<4;row_index++) {
        let row = wheelstable.insertRow();
        for (let col_index = 0; col_index < 5; col_index++) {
            let cell = row.insertCell();
            wheelstablecells[cell_index] = cell;
            cell.classList.add("wheelscell");
            cell.appendChild(document.createTextNode("❓"));    // Question mark
            cell_index++;
            //console.log("index="+cell_index+" row="+row_index+" col="+col_index)
        }
    }

    function onmousedownhandler(e,c,b) {
        clickHandler( c , b  );
    }

    function onmouseenterhander(e,c,b) {
        if (e.buttons & 0x01) clickHandler( c, b )
    };


    let bit_index =0;
    let kenotable = document.getElementById("kenotable");
    for(let row_index=0; row_index<10;row_index++) {
        let row = kenotable.insertRow();
        for( let col_index=0; col_index<8;col_index++) {
            let cell = row.insertCell();
            cell.classList.add("kenocell");
            let text = document.createTextNode( " " +  (bit_index+1));
            cell.appendChild(text);
            let tempvalue_of_bit_index = bit_index;
            cell.onmousedown = function () {clickHandler( cell ,  tempvalue_of_bit_index   )};
            cell.onmouseenter = function (e) { if (e.buttons & 0x01) clickHandler( cell ,tempvalue_of_bit_index  ) };
            bits[bit_index]=0;
            bit_index++;
            //console.log("bi="+bit_index);
        }
    }
</script>

<!--
    This is a Browserfy'ed version of the popular bitcoinjs package.
    To verify it is trustworthy for yourself, check out /js/bitcoinjs.MD
    We only use it to generate the public ECSDA key and do some formatting.
    Sorry, I could not bring myself to write this stuff in Javascript. If
    you know a clean alternative I can use, please suggest it. I do not
    want to use the subtlecrypto stuff because it has the absurd requirement
    that it will only generate keys when loaded over SSL. This seems like a
    deep misunderstanding of crypto. Please correct me if I am wrong.
-->

<script src="js/bitcoinjs.min.js">
</script>
<script>
    const TESTNET = bitcoinjs.networks.testnet;
    const MAINNET = bitcoinjs.networks.main;

    const network = TESTNET;
    const keyPair = bitcoinjs.ECPair.makeRandom();
    const address1  = bitcoinjs.payments.p2pkh({ pubkey: keyPair.publicKey ,  network  }).address;
    const pubkey = keyPair.publicKey;
    const privateKey = keyPair.privateKey;
    const wif = keyPair.toWIF();
    console.log(pubkey);
    console.log(address1);
    console.log(wif);


    // Lets make a block
    // https://github.com/bitcoinjs/bitcoinjs-lib/blob/master/ts_src/block.ts

    let block= new bitcoinjs.Block();        // Set up all the fields

    // https://developer.bitcoin.org/reference/block_chain.html

    // Lets try this first
    // https://www.blockchain.com/btc/block/000000000000000000039f8b1a2c48ee1dacd581e7cacb560e75d8de051cc0e1
    block.version = Number.parseInt( "2000e000" , 16 );

    block.prevHash = bitcoinjs.buffer.Buffer.from("00000000000000000000120caab7c1caeb4aad6e9dc242e7530d543edd4f6a27","hex").reverse();
    block.merkleRoot = bitcoinjs.buffer.Buffer.from("b847ca78b242364926cd5a11469c8b98864ce1af031f5ed3567041a22a8ac2f5","hex").reverse();
    block.timestamp = 1619825649;
    block.bits = 0x170bef93; //bitcoinjs.buffer.Buffer.from("170bef93","hex");
    block.nonce = 1334528400;

    let blockhex = block.toHex(true);       // True is headers only
    console.log( "block="+blockhex);

    let blockhash= block.getHash();
    let blockhashhex = blockhash.toString("hex");       // True is headers only

    console.log( "blockhash=" + blockhashhex);

    // Now lets try adding a coinbase transaction to the block
    // Here is an empty block we can use as a template:
    // d8025d52f6d10559f60207f4f9db2545f1935ef69a5b418e9b2ae6e711b654e6
    // It has one transaction:
    // d8025d52f6d10559f60207f4f9db2545f1935ef69a5b418e9b2ae6e711b654e6
    // As raw Hex:
    // https://blockchain.info/tx/d8025d52f6d10559f60207f4f9db2545f1935ef69a5b418e9b2ae6e711b654e6?format=hex
    // 010000000001010000000000000000000000000000000000000000000000000000000000000000ffffffff5403e8650a1b4d696e656420627920416e74506f6f6c37363978002902b7c70781fabe6d6d83410bf4ea571acde5acecff1587f39ff6b027f422575e933acf1043d0ccee3002000000000000009af000001a070000ffffffff0440be4025000000001976a91411dbe48cc6b617f9c6adaf4d9ed5f625b1c7cb5988ac0000000000000000266a24aa21a9ede2f61c3f71d1defd3fa999dfa36953755c690689799962b48bebd836974e8cf90000000000000000266a24b9e11b6d45d19962c0f444142e898f64a94b73324896afa4adfe794cf63e0f3cd521f6df00000000000000002b6a2952534b424c4f434b3a1ba6a546d2bcb116f744b51c4749d02e4fcd6ceb2d158fb5c14b3828003293ec0120000000000000000000000000000000000000000000000000000000000000000000000000
    // 01000000: Version 1
    // 00 : Input count?
    // 01010000000000000000000000000000000000000000000000000000000000000000ffffffff5403e8650a1b4d696e656420627920416e74506f6f6c37363978002902b7c70781fabe6d6d83410bf4ea571acde5acecff1587f39ff6b027f422575e933acf1043d0ccee3002000000000000009af000001a070000ffffffff0440be4025000000001976a91411dbe48cc6b617f9c6adaf4d9ed5f625b1c7cb5988ac0000000000000000266a24aa21a9ede2f61c3f71d1defd3fa999dfa36953755c690689799962b48bebd836974e8cf90000000000000000266a24b9e11b6d45d19962c0f444142e898f64a94b73324896afa4adfe794cf63e0f3cd521f6df00000000000000002b6a2952534b424c4f434b3a1ba6a546d2bcb116f744b51c4749d02e4fcd6ceb2d158fb5c14b3828003293ec0120000000000000000000000000000000000000000000000000000000000000000000000000
    //

    // https://medium.com/@aniketdivekar/bitcoin-create-sign-and-push-transaction-2ea877c08ab4

    const psbt = new bitcoinjs.Psbt( { network: network } );

    psbt.addOutput( { address: address1 , value: 5e8 } );      // We don't be greedy.

    console.log( "out tx="+ psbt.extractTransaction(true).toHex() );

    // Let's build a raw coinbase transaction from scratch since I can not figure out how to do it in bitcoinjs

    let txbuffer = bitcoinjs.buffer.Buffer( 4+1+4+4+1+1+4+4 );

    txbuffer.writeUInt32LE(0x01);   // Version number. Currently 0x02 based on looking at recent coinbase transactions.
    txbuffer.writeUInt8( 0x01 );    // Input count

    // First (only) input, Coinbase tx
    txbuffer.writeUInt32LE(0x00000000);     // source hash - null by convention
    txbuffer.writeUInt32LE(0xffffffff);     // source index - -1 by convention
    txbuffer.writeUInt8(0x05);              // script len (the script directly below is 5 bytes

    // We need to push the block number on the stack as per BIP-0034
    txbuffer.writeUInt8( 0x04);             // OP_PUSHBYTES_4 - Will this work (currently everyone does only 3 bytes)
    txbuffer.writeUInt32LE( block.height );

    txbuffer.writeUInt32LE( 0xffffffff);    // Sequence number - seems to always be -1

    block.transactions.write( txbuffer );

    // todo add output p2pk hash, op_checksig

</script>



</body>
</html>
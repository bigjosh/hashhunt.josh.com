<!doctype html>

<!---

    Dear skeptical reviewer,

    I am so glad you are here. It was not without great personal discomfort that I crafted Hash Hunt
    using only the most primitive and brutal tools available: Javascript, CSS, and HTML.

    Why? I did it for you. So that you, gentle reader, could directly and independently verify that all
    my claims are absolutely and factually true. Code cannot lie and so here is, naked and unminified
    for your thoughtful inspection.

    By the time you get to the end of this file, you will see that...

    1) It is possible for a user to pick a winning combination of numbers.
    2) Five bitcoin will be awarded to the first user to find a winning combination in each round.
    3) At no time will I ever touch the user's winnings or even have the opportunity to. The user
       will be able to claim their winnings directly using any bitcoin wallet that accepts a WIF formatted
       private key (all of them).

    These are factual assertions, and I am certain that you will find nothing to contradict them.

    Thank you for your participation.

    -josh

--->

<html lang="en">
<head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- Favicon codes generated by https://realfavicongenerator.net/ -->
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">

    <!-- Nice google fonts  -->
    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link href="https://fonts.googleapis.com/css2?family=Girassol&family=Roboto&display=swap" rel="stylesheet">

    <title>Hash Hunt!</title>
</head>


<style>

    body {
        font-family: 'Roboto', sans-serif;
    }

    .kenocell {
        padding-top: 10px;
        padding-bottom: 10px;
        margin: 15px;
        text-align: center;
        border-style: solid;
        border-width: 1px;
        cursor: pointer;
        user-select: none;
    }

    .kenocell_selected {
        background: #a52834;
    }

    .wheelscell {
        /*
        padding-top: 10px;
        padding-bottom: 10px;
        */
        text-align: center;
        border-style: solid;
        border-width: 1px;
        cursor: pointer;
        font-weight: bold;
        font-size: 1.5em;
    }

    @keyframes hash_cell_animation {
        0% {

        }

        100% {
            transform: scale(1.2);
            background: chartreuse;
        }
    }

    .wheels_cell_hash {
        animation-name: hash_cell_animation;
        animation-duration: 0.2s;
        animation-iteration-count: infinite;
        animation-direction: alternate;
    }

    table {
        table-layout: fixed;
    }

</style>
<body>
<div style="width: 100%; max-width: 600px; align-content: center;">

    <div style="display: block; width: 100%;">
        <table style="width: 100%;">
            <tr>
                <td>
                    <table style="display: inline;">
                        <tr><td><hr style="margin: 1px 0px 1px 0px; "></td></tr>
                        <tr><td><div style="box-sizing:border-box;"><span style="font-family: 'Girassol', serif ;font-size: large; padding: 5px; background: black; color:white; display:inline-block;">HASH HUNT</span></div></td></tr>
                        <tr><td><hr style="margin: 1px 0px 1px 0px; "></td></tr>
                    </table>
                </td>
                <td style="text-align: right; padding-right: 10px;">
                    <a href="info.html">more info</a><br><br>
                    Round elapsed time <span id="etime">00:00:00</span>
                </td>
            </tr>
        </table>
    </div>

    <div style="display: block; width: 100%;">
        <table id="wheelsTable" style="width: 100%;"></table>
    </div>

<!--    <div style="display: block; width: 100%;">-->
<!--        <td><hr></td>-->
<!--    </div>-->

    <div style="display: block; width: 100%;">
        <table id="kenotable" style="width: 100%;"></table>
    </div>
</div>

<script>

    var seconds = 0;
    var et = document.getElementById('etime');

    function incrementSeconds() {
        seconds += 1;
        et.innerText = new Date(seconds * 1000).toISOString().substr(11, 8);        //https://stackoverflow.com/a/1322771/3152071
    }

    setInterval(incrementSeconds, 1000);

</script>

<!-- Import a clean, no-dependency sha256 function -->
<!-- From https://www.movable-type.co.uk/scripts/sha256.html#src-code -->
<!-- Noticeably faster then the bitcoinjs one. -->
<!-- Note I removed the `export` line at the end to avoid modules. -->
<script  src="js/sha256.js" ></script>

<script>

    // Number of hashwheels to show. We might need to update this bigger after a big difficulty adjustment.
    var hashwheel_count = 20;

    // Quick access to the textContent of the cells.
    var wheelstablecells = [];

    // Set wheel w to the given value. 0=Hash, others=fruits
    function setWheel(w,v) {

        let cell = wheelstablecells[w];

        let t;

        if (v===0) {             // Winning wheel?
            t = "#";             // The magic hash
            cell.classList.add( "wheels_cell_hash");
        } else {
           t = String.fromCodePoint(127811+v );                // Fruits - https://www.w3schools.com/charsets/ref_emoji.asp#:~:text=127813
           cell.classList.remove( "wheels_cell_hash");
        }

        cell.innerHTML = t;
        //console.log( "wheel="+w+" t="+t + "v=" +v);
    }

    // Set all the wheels according to the leading bytes of v
    // v is a string of hex digits at least `difficulty` in length
    function setwheels(v) {
        for( let i=0; i<hashwheel_count;i++ ) {
            setWheel(i, Number.parseInt( v[i] , 16  ) );
        }

    }

    // We want this to be a global so we use `var` on purpose
    var bits=[];

    function toBin( b ) {
        let s="";
        for( let i =0 ; i< bits.length; i++ ) {
            s = ( b[i] ? "1":"0" ) + s;
        }
        return s;
    }

    function clickHandler(cell,bit) {

        console.log("clickhandler cell="+cell+" bit="+bit+" bits="+ toBin(bits) );

        if (bits[bit]) {
            cell.classList.remove("kenocell_selected");
            bits[bit]=false;
        } else {
            cell.classList.add("kenocell_selected");
            bits [bit]=true;
        }
        var hasstr = "X"+toBin(bits)
        //hasstr = "abc";

        var out = bitcoinjs.crypto.sha256( bitcoinjs.buffer.Buffer( hasstr )).toString("hex");
        //var out = Sha256.hash(Sha256.hash( hasstr));
        //console.log( "hex="+ hasstr +" out="+out);

        setwheels(out);
    }

    let wheelstable = document.getElementById("wheelsTable");
    let cell_index=0;
    const wheelstablecols = 5;      // Must be an integer factor of 20 for now.
    let row_index=0;
    while ( cell_index < 20 ) {
        let row = wheelstable.insertRow();
        for (let col_index = 0; col_index < wheelstablecols; col_index++) {
            let cell = row.insertCell();
            wheelstablecells[cell_index] = cell;
            cell.classList.add("wheelscell");
            cell.appendChild(document.createTextNode("â“"));    // Question mark
            cell_index++;
            //console.log("index="+cell_index+" row="+row_index+" col="+col_index)
        }
        row_index++;
    }

    function onmousedownhandler(e,c,b) {
        clickHandler( c , b  );
    }

    function onmouseenterhander(e,c,b) {
        if (e.buttons & 0x01) clickHandler( c, b )
    };


    let bit_index =0;
    let kenotable = document.getElementById("kenotable");
    for(let row_index=0; row_index<10;row_index++) {
        let row = kenotable.insertRow();
        for( let col_index=0; col_index<8;col_index++) {
            let cell = row.insertCell();
            cell.classList.add("kenocell");
            let text = document.createTextNode( " " +  (bit_index+1));
            cell.appendChild(text);
            let tempvalue_of_bit_index = bit_index;
            cell.onmousedown = function () {clickHandler( cell ,  tempvalue_of_bit_index   )};
            cell.onmouseenter = function (e) { if (e.buttons & 0x01) clickHandler( cell ,tempvalue_of_bit_index  ) };
            bits[bit_index]=0;
            bit_index++;
            //console.log("bi="+bit_index);
        }
    }
</script>

<!--
    This is a Browserfy'ed version of the popular bitcoinjs package.
    To verify it is trustworthy for yourself, check out /js/bitcoinjs.MD.
    Sorry, I could not bring myself to write this stuff in Javascript. If
    you know a clean alternative I can use, please suggest it. I do not
    want to use the subtlecrypto stuff because it has the absurd requirement
    that it will only generate keys when loaded over SSL. This seems like a
    deep misunderstanding of crypto. Please correct me if I am wrong.
-->

<script src="js/bitcoinjs.min.js">
</script>

<script>
    // All Globals here so we can keep track of them
    var network;        // Test or Main
    var keyPair;        // User's keypair
</script>

<script>

    network = bitcoinjs.networks.testnet;
    //network = bitcoinjs.networks.main;

    keyPair = bitcoinjs.ECPair.makeRandom();
    const address1  = bitcoinjs.payments.p2pkh({ pubkey: keyPair.publicKey ,  network  }).address;
    const pubkey = keyPair.publicKey;
    const privateKey = keyPair.privateKey;
    const wif = keyPair.toWIF();
    console.log(pubkey);
    console.log(address1);
    console.log(wif);

    // Lets make a block
    // https://github.com/bitcoinjs/bitcoinjs-lib/blob/master/ts_src/block.ts

    let block= new bitcoinjs.Block();        // Set up all the fields

    // https://developer.bitcoin.org/reference/block_chain.html

    // Lets try this first
    // https://www.blockchain.com/btc/block/000000000000000000039f8b1a2c48ee1dacd581e7cacb560e75d8de051cc0e1
    block.version = 0x20000000;

    block.prevHash = bitcoinjs.buffer.Buffer.from("49b024a553abf2a23d41ea04e2d64d4e5a33039c86e739299ec13df10e9e7859","hex").reverse();
    block.merkleRoot = bitcoinjs.buffer.Buffer.from("b847ca78b242364926cd5a11469c8b98864ce1af031f5ed3567041a22a8ac2f5","hex").reverse();
    block.timestamp = 1620106834;
    block.bits = 0x207fffff;
    block.nonce = 0;

    let blockhex = block.toHex(true);       // True is headers only
    console.log( "block="+blockhex);

    let blockhash= block.getHash();
    let blockhashhex = blockhash.toString("hex");       // True is headers only

    console.log( "blockhash=" + blockhashhex);

    // Shortcut to make an oversized buffer
    function makeOversizedBuffer()
    {
        return bitcoinjs.buffer.Buffer(256);
    }

    // How can the API not come with this function?!
    bitcoinjs.buffer.Buffer.prototype.writeBuffer = function ( b , o  ) {
        return o+b.copy( this , o  );
    }

    // How can the API not come with this function?!
    bitcoinjs.buffer.Buffer.prototype.writeUInt24LE = function ( x , o  ) {

        let b2 = ((x >> 16) & 0xff);
        let b1 = ((x >>  8) & 0xff);
        let b0 = ((x >>  0) & 0xff);

        o=this.writeUInt8( b0 , o );
        o=this.writeUInt8( b1 , o );
        o=this.writeUInt8( b2 , o );

        return o;
    }

    // Write a bitcoin varint type
    // Defined here https://developer.bitcoin.org/reference/transactions.html#compactsize-unsigned-integers
    bitcoinjs.buffer.Buffer.prototype.writeVarint = function ( x , o  ) {

        if ( x <= 252 ) {
            o = this.writeUInt8(x, o);             // Small numbers are themselves
        } else if (x <=0xffff) {
            o = this.writeUInt8(0xfd, o);             // Prefix
            o = this.writeUInt16LE(x, o);             // Prefix
        } else if ( x<=  0xffffffff ) {
            o = this.writeUInt8(0xfe, o);             // Prefix
            o = this.writeUInt32LE(x, o);             // Prefix
        } else if ( x<=  0xffffffffffff ) {
            o = this.writeUInt8(0xff, o);             // Prefix
            o = this.writeUInt24LE(x, o);             // Prefix
            o = this.writeUInt8( 0, o);               // We only support up to 24 bits, fill top with 0
        } else {
            console.error( "Number too big in writeVarint:" + x );
        }
        return o;
    }



    // How can the API not come with this function?!
    bitcoinjs.buffer.Buffer.prototype.fillByte = function ( b , c , o  ) {
        while (c) {
            o=this.writeUInt8( b , o );
            c--;
        }
        return o;
    }

    // How can the API not come with this function?!
    bitcoinjs.buffer.Buffer.prototype.asReversed = function () {
        let r = bitcoinjs.buffer.Buffer( this.length );

        for( let s=0; s< this.length ; s++ ) {

            r[(this.length-s)-1] = this[s];
        }

        return r;
    }


    // Now lets try adding a coinbase transaction to the block
    // Here is an empty block we can use as a template:
    // d8025d52f6d10559f60207f4f9db2545f1935ef69a5b418e9b2ae6e711b654e6
    // It has one transaction:
    // d8025d52f6d10559f60207f4f9db2545f1935ef69a5b418e9b2ae6e711b654e6
    // As raw Hex:
    // https://blockchain.info/tx/d8025d52f6d10559f60207f4f9db2545f1935ef69a5b418e9b2ae6e711b654e6?format=hex
    // 010000000001010000000000000000000000000000000000000000000000000000000000000000ffffffff5403e8650a1b4d696e656420627920416e74506f6f6c37363978002902b7c70781fabe6d6d83410bf4ea571acde5acecff1587f39ff6b027f422575e933acf1043d0ccee3002000000000000009af000001a070000ffffffff0440be4025000000001976a91411dbe48cc6b617f9c6adaf4d9ed5f625b1c7cb5988ac0000000000000000266a24aa21a9ede2f61c3f71d1defd3fa999dfa36953755c690689799962b48bebd836974e8cf90000000000000000266a24b9e11b6d45d19962c0f444142e898f64a94b73324896afa4adfe794cf63e0f3cd521f6df00000000000000002b6a2952534b424c4f434b3a1ba6a546d2bcb116f744b51c4749d02e4fcd6ceb2d158fb5c14b3828003293ec0120000000000000000000000000000000000000000000000000000000000000000000000000
    // 01000000: Version 1
    // 00 : Input count?
    // 01010000000000000000000000000000000000000000000000000000000000000000ffffffff5403e8650a1b4d696e656420627920416e74506f6f6c37363978002902b7c70781fabe6d6d83410bf4ea571acde5acecff1587f39ff6b027f422575e933acf1043d0ccee3002000000000000009af000001a070000ffffffff0440be4025000000001976a91411dbe48cc6b617f9c6adaf4d9ed5f625b1c7cb5988ac0000000000000000266a24aa21a9ede2f61c3f71d1defd3fa999dfa36953755c690689799962b48bebd836974e8cf90000000000000000266a24b9e11b6d45d19962c0f444142e898f64a94b73324896afa4adfe794cf63e0f3cd521f6df00000000000000002b6a2952534b424c4f434b3a1ba6a546d2bcb116f744b51c4749d02e4fcd6ceb2d158fb5c14b3828003293ec0120000000000000000000000000000000000000000000000000000000000000000000000000
    //

    // https://medium.com/@aniketdivekar/bitcoin-create-sign-and-push-transaction-2ea877c08ab4


    // Push a value on the stack using the most efficient OP code
    function pushValueScriptOps( d ) {
        let b = bitcoinjs.buffer.Buffer( 256 );     // This is lazy, but I am bad at counting
        let o=0;

        // All the op codes 1-75 mean "push x bytes on stack"

        if ( d < (1<<8) ) {
            o=b.writeUInt8( 0x01 , o );                             // 1 byte of data OP_CODE
            o=b.writeUInt8(    d , o );
        } else if ( d < (1<<16) ) {
            o=b.writeUInt8( 0x02 , o );                             // 2 byte of data OP_CODE
            o=b.writeUInt16LE(  d , o );
        } else if ( d < (1<<24) ) {
            o=b.writeUInt8( 0x03 , o );                             // 3 byte of data OP_CODE
            o=b.writeUInt24LE(   d , o );
        } else if ( d < (1<<32) ) {
            o = b.writeUInt8(0x04, o);                             // 4 byte of data OP_CODE
            o = b.writeUInt32LE( d, o);
        } else {
            console.error( "Value to big in pushValueScript "+ d );
        }

        return b.slice(0,o);
    }

    // Push a buffer on the stack using the most efficient OP code
    function pushBufferScriptOps( s ) {
        let b = bitcoinjs.buffer.Buffer( 256 );     // This is lazy, but I am bad at counting
        let o=0;

        // All the op codes 1-75 mean "push x bytes on stack"
        if (s.length <= 75 ) {
            o = b.writeUInt8(s.length, o);                             // 1 byte of data OP_CODE
        } else if (s.length < (1<<8) ) {
            o=b.writeUInt8(  bitcoinjs.opcodes.OP_PUSHDATA1 , o );
            o=b.writeUInt8( s.length , o );
        } else if ( s.length < (1<<16) ) {
            o=b.writeUInt8( bitcoinjs.opcodes.OP_PUSHDATA2  , o );                             // 2 byte of data OP_CODE
            o=b.writeUInt16LE(  s.length , o );
        } else if ( s.length < (1<<24) ) {
            o=b.writeUInt8( bitcoinjs.opcodes.OP_PUSHDATA3   , o );                             // 3 byte of data OP_CODE
            o=b.writeUInt24LE(   s.length , o );
        } else if ( s.length < (1<<32) ) {
            o = b.writeUInt8( bitcoinjs.opcodes.OP_PUSHDATA4  , o);                             // 4 byte of data OP_CODE
            o = b.writeUInt32LE( s.length, o);
        } else {
            console.error( "Value to big in pushValueScript "+ d );
        }

        // Write the actual data itself
        o=b.writeBuffer( s , o );

        return b.slice(0,o);
    }


    // Let's build a raw coinbase transaction from scratch since I can not figure out how to do it in bitcoinjs

    function pushHeightScript( blockheight ) {
        let b = bitcoinjs.buffer.Buffer( 256 );     // This is lazy, but I am bad at counting
        let o=0;

        // We need to push the block number on the stack as per BIP-0034
        let pushBlockheightOps = pushValueScriptOps(blockheight);
        o=b.writeBuffer(pushBlockheightOps,o);

        console.log("script:" + blockheight );
        console.log( b.slice(0,o).toString("hex"));

        // Here we get to stick in a little message in the coinbase
        o=b.writeBuffer( bitcoinjs.buffer.Buffer.from("/Play Hashhunt.josh.com/") , o );
        console.log("with mesage:" + blockheight );
        console.log( b.slice(0,o).toString("hex"));

        return b.slice(0,o);
    }

    // Creates a coinbase input transaction. Takes blockheight as a num. Returns a buffer.
    function coinbaseTx( blockheight ) {
        let b = bitcoinjs.buffer.Buffer( 256 );
        let o=0;
        o=b.fillByte( 0x00 , 32 , o  );      // source hash - null by convention
        o=b.writeUInt32LE(0xffffffff,o);     // source index - -1 by convention

        // We need to push the block number on the stack as per BIP-0034
        let coinbasescript= pushHeightScript( blockheight );

        o=b.writeVarint( coinbasescript.length , o );
        o=b.writeBuffer( coinbasescript , o );

        o=b.writeUInt32LE( 0xffffffff ,o);    // Sequence number - seems to always be -1

        console.log("coinbase:");
        console.log("height:" + blockheight );
        console.log( b.slice(0,o).toString("hex"));

        return b.slice(0,o);
    }

    // Creates a single P2PK locking script
    // Takes a buffer with the public key, returns a buffer
    function outScript( pubkey ) {
        let b = makeOversizedBuffer();
        let o = 0;
        // Simplest lock script is to push a publick key and the OP_CHECK sig
        let pushPKops = pushBufferScriptOps( pubkey );
        o=b.writeBuffer( pushPKops  , o );
        o=b.writeUInt8(  bitcoinjs.opcodes.OP_CHECKSIG , o );
        return b.slice(0,o);
    }

    // Create a normal P2PK tx
    // Value is number of satoshis. Must be < 2^32.
    // Pubkey is a buffer with the public key.
    // Returns a buffer.
    function P2PKOut( value , pubkey ) {
        let b = makeOversizedBuffer();
        let o = 0;
        o=b.writeUInt32LE(value , o);           // Write the lower 32 bits of value we are sending.
        o=b.writeUInt32LE( 0 , o);              // Full field is 64 bits, so write zeros in upper 32 bits.
        let outscriptBuffer = outScript(pubkey);
        o=b.writeUInt8( outscriptBuffer.length , o);
        o=b.writeBuffer( outscriptBuffer , o );
        return b.slice(0,o);
    }

    // Create a standard  P2PKH lock script
    // Pubkey is a buffer public key
    // Returns a buffer.
    function P2PKHOutScript( pubkey ) {
        let b = makeOversizedBuffer();     // This is lazy, but I am bad at counting
        let o = 0;
        // Below is the standard P2PKH script: OP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG
        // Helpful for debugging this.. https://siminchen.github.io/bitcoinIDE/build/editor.html
        // (took 1 hour to figure out that pubkeyhash.len should have been pubkeyhash.length. I hate JS.)

        o=b.writeUInt8( bitcoinjs.opcodes.OP_DUP , o );
        o=b.writeUInt8( bitcoinjs.opcodes.OP_HASH160 , o );

        let pubkeyhash = bitcoinjs.crypto.hash160( pubkey );

        let pushPubKeyOps = pushBufferScriptOps( pubkeyhash );
        o=b.writeBuffer( pushPubKeyOps , o );

        o=b.writeUInt8( bitcoinjs.opcodes.OP_EQUALVERIFY , o );
        o=b.writeUInt8( bitcoinjs.opcodes.OP_CHECKSIG , o );

        return b.slice(0,o);
    }

    // Create a normal P2PKH tx
    // value is satoshis
    // Pubkey is a buffer public key
    // Returns a buffer.

    function P2PKHOutTx( value , pubkey ) {
        let b = makeOversizedBuffer();
        let o = 0;

        o=b.writeUInt32LE( value, o);               // Write the lower 32 bits of value in satoshis
        o=b.writeUInt32LE( 0 , o);                  // Full field is 64 bits, so write zeros in upper 32 bits.

        console.log("value:")
        console.log( value.toString( 16) );

        let outTxScript = P2PKHOutScript( pubkey );

        console.log("outTxScript:")
        console.log( outTxScript.toString("hex") );

        o=b.writeVarint( outTxScript.length , o );              // Out script len
        o=b.writeBuffer( outTxScript , o );

        return b.slice(0,o);
    }


    let b = bitcoinjs.buffer.Buffer( 256 );       // Oversize for now
    let o = 0;

    o=b.writeUInt32LE(0x01 , o );   // Version number. Currently 0x01 based on looking at recent coinbase transactions.

    // First inputs
    o=b.writeUInt8( 0x01  , o );    // Input count
    let inTx = coinbaseTx( 123456 ,o );
    o=b.writeBuffer( inTx , o);

    console.log("after cb:")
    console.log( b.slice(0,o).toString("hex") );

    // Then outputs
    o=b.writeUInt8( 0x01 , o  );     // Output count
    let outTx = P2PKHOutTx( 5 * 1e8  , keyPair.publicKey );
    o=b.writeBuffer( outTx , o  );

    o=b.writeUInt32LE( 0x00000000 , o );        // Locktime

    var coinbaseTransaction = b.slice(0,o);

    console.log("TX:");
    console.log( coinbaseTransaction.toString("hex") );

    // Hand code prev hash for now...
    block.prevHash = bitcoinjs.buffer.Buffer.from("367d631b6fd28a8cbf79513c20111463e777793a695c696ea8b2e9ef7aff65c8","hex").asReversed();

    // Ok, now we can put the coinbase transaction into the block
    block.merkleRoot = bitcoinjs.crypto.sha256( bitcoinjs.crypto.sha256( coinbaseTransaction ) );

    console.log("Merkle:");
    console.log( block.merkleRoot.toString("hex") );

    block.timestamp = 1620111482+(3600);

    // OK, now we can start mining!

    do {
        block.nonce++;

        blockhash =  block.getHash();

    } while ((blockhash[31] | blockhash[30]) > 0 );

    /*
    // For testing force this block to be the one I see now so I can compare
    block.prevHash = bitcoinjs.buffer.Buffer.from("367d631b6fd28a8cbf79513c20111463e777793a695c696ea8b2e9ef7aff65c8","hex").asReversed();
    block.nonce = 1;
    block.merkleRoot = bitcoinjs.buffer.Buffer.from("c40a1e396b379545d12dcc6b26256d9173a9c6f27da6b3f3af04987749613b7d","hex").asReversed();
    block.timestamp = 1620111482;
    */
    console.log("blockhash:");
    console.log( blockhash.toString("hex") );

    console.log("block:");
    console.log( block.toBuffer().toString("hex") );

    let serializedblockBuffer = makeOversizedBuffer();
    o=0;

    o=serializedblockBuffer.writeBuffer( block.toBuffer() , o );
    o=serializedblockBuffer.writeVarint( 0x01 , o );        // Transaction count
    o=serializedblockBuffer.writeBuffer( coinbaseTransaction , o );

    let serializedBlock = serializedblockBuffer.slice( 0 , o);

    console.log("serialized block:");
    // noinspection JSCheckFunctionSignatures
    console.log( serializedBlock.toString("hex") );

</script>

</body>
</html>
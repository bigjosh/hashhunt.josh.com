<!doctype html>

<!---

    Dear skeptical reviewer,

    I am so glad you are here. It was not without great personal discomfort that I crafted Hash Hunt
    using only the most primitive and brutal tools available: Pure Javascript, CSS, and HTML.

    Why? I did it for you. So that you, gentle reader, could directly and independently verify that all
    my claims are absolutely and factually true. Code cannot lie and so here is, naked and unminified
    for your thoughtful inspection.

    By the time you get to the end of this file, you will see that...

    1) It is possible for a user to pick a winning combination of numbers.
    2) Five bitcoin  will be awarded to the first user to find a winning combination in each round.
    3) At no time will I ever touch the user's winnings or even have the opportunity to. The user
       will be able to claim their winnings directly using any bitcoin wallet that accepts a WIF formatted
       private key (all of them).

    These are factual assertions, and I am certain that you will find nothing to contradict them.

    We are all readers and writers of code here. We speak in languages with strict definitions and specifications.
    We are committed to the goal of representing ideas and processes precisely and correctly. Some live in a
    qualitative world of blurry boarders and uncertain distinctions. We do not. We know that zero is zero, and
    any other number, no matter how small, is still not zero. Zero is a singularity, defined by its not being
    any other number.

    With this in mind, I will ask you to remember that there is a categorical difference between "non-zero chance"
    and "zero chance". While there are levels of probability that you (and I) might consider so small as to be de
    minimis, there are many who do not share our opinion. If you doubt this, try computing the expected value of a
    Powerball ticket. So I respectfully ask that you please do try to avoid making the error of conflating "highly
    unlikely" with "impossible". And always be ready to update your priors when presented with new evidence.

    And, finally, remember that there is also a non-zero chance that our intuitions about luck and probability in
    this context are wrong!

    You are an important part of this grand experiment. Thank you for your participation.

    -josh

--->

<html lang="en">
<head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- Favicon codes generated by https://realfavicongenerator.net/ -->
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">

    <!-- Nice google fonts  -->
    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link href="https://fonts.googleapis.com/css2?family=Girassol&family=Roboto&display=swap" rel="stylesheet">

    <title>Hash Hunt!</title>
</head>


<style>

    body {
        font-family: 'Roboto', sans-serif;;
    }

    .kenocell {
        padding: 20px 25px;
        margin: 15px;
        text-align: center;
        border-style: solid;
        border-width: 1px;
        cursor: pointer;
        user-select: none;
    }

    .kenocell_selected {
        background: #a52834;
    }

    .wheelscell {
        padding: 10px 10px;
        text-align: center;
        border-style: solid;
        border-width: 1px;
        cursor: pointer;
        font-weight: bold;
        font-size: 1.5em;
    }

    @keyframes hash_cell_animation {
        0% {

        }

        100% {
            transform: scale(1.2);
            background: chartreuse;
        }
    }

    .wheels_cell_hash {
        animation-name: hash_cell_animation;
        animation-duration: 0.2s;
        animation-iteration-count: infinite;
        animation-direction: alternate;
    }

</style>
<body>
<table>
    <tr><td><hr style="margin: 1px 0px 1px 0px; "></td></tr>
    <tr><td><div style="box-sizing:border-box;"><span style="font-family: 'Girassol', serif ;font-size: xx-large; padding: 10px; background: black; color:white; display:inline-block;">HASH HUNT</span></div></td></tr>
    <tr><td><hr style="margin: 1px 0px 1px 0px; "></td></tr>
</table>
<ul>
    <li>Click numbers to toggle.</li>
    <li>Make all the reels come up hashes.</li>
    <li>First to find winning pattern gets 5 bitcoin.</li>
    <li>Round continues until winning pattern is found.</li>
    <li>New patterns in each round.</li>
</ul>

<table>
    <tr style="width: 100%;"><td style="width: 100%;">
        <table id="wheelsTable" style="width: 100%;"></table>
    </td></tr>

    <tr><td>

    <!---   Debug info on the bits and the hash
        <div id="in" style="font-family: 'Courier New',monospace" >NOT SET YET</div>
        <div id="out" style="font-family: 'Courier New',monospace">NOT SET YET</div>
    --->
    </td></tr>

    <tr><td>
        <table id="kenotable"></table>
    </td></tr>
</table>

<!-- Import a clean, no-dependency sha256 function -->
<!-- From https://www.movable-type.co.uk/scripts/sha256.html#src-code -->
<!-- Noticeably faster then the bitcoinjs one. -->
<!-- Note I removed the `export` line at the end to avoid modules. -->
<script  src="js/sha256.js" ></script>

<script>

    // Number of leading hex 0's we need to get to win
    var difficulty = 20;

    // Quick access to the textContent of the cells.
    var wheelstablecells = [];

    // Set wheel w to the given value. 0=Bitcoin, others=fruits
    function setWheel(w,v) {

        let cell = wheelstablecells[w];

        let t;

        if (v===0) {             // Winning wheel?
            t = "#";             // The magic hash
            cell.classList.add( "wheels_cell_hash");
        } else {
           t =  "&#" + (127811+v) +";";  // Fruits
           cell.classList.remove( "wheels_cell_hash");
        }

        cell.innerHTML = t;
        //console.log( "wheel="+w+" t="+t + "v=" +v);
    }

    // Set all the wheels according to the leading bytes of v
    // v is a string of hex digits at least `difficulty` in length
    function setwheels(v) {
        for( let i=0; i<difficulty;i++ ) {
            setWheel(i, Number.parseInt( v[i] , 16  ) );
        }

    }

    // We want this to be a global so we use `var` on purpose
    var bits=[];

    function toBin( b ) {
        let s="";
        for( let i =0 ; i< bits.length; i++ ) {
            s = ( b[i] ? "1":"0" ) + s;
        }
        return s;
    }

    function clickHandler(cell,bit) {

        console.log("clickhandler cell="+cell+" bit="+bit+" bits="+ toBin(bits) );

        if (bits[bit]) {
            cell.classList.remove("kenocell_selected");
            bits[bit]=false;
        } else {
            cell.classList.add("kenocell_selected");
            bits [bit]=true;
        }
        var hasstr = "X"+toBin(bits)
        //hasstr = "abc";

        var out = bitcoinjs.crypto.sha256( bitcoinjs.buffer.Buffer( hasstr )).toString("hex");
        //var out = Sha256.hash(Sha256.hash( hasstr));
        //console.log( "hex="+ hasstr +" out="+out);

        setwheels(out);
    }

    let wheelstable = document.getElementById("wheelsTable");
    let cell_index=0;
    for(let row_index=0; row_index<4;row_index++) {
        let row = wheelstable.insertRow();
        for (let col_index = 0; col_index < 5; col_index++) {
            let cell = row.insertCell();
            wheelstablecells[cell_index] = cell;
            cell.classList.add("wheelscell");
            cell.appendChild(document.createTextNode("❓"));    // Question mark
            cell_index++;
            //console.log("index="+cell_index+" row="+row_index+" col="+col_index)
        }
    }

    function onmousedownhandler(e,c,b) {
        clickHandler( c , b  );
    }

    function onmouseenterhander(e,c,b) {
        if (e.buttons & 0x01) clickHandler( c, b )
    };


    let bit_index =0;
    let kenotable = document.getElementById("kenotable");
    for(let row_index=0; row_index<10;row_index++) {
        let row = kenotable.insertRow();
        for( let col_index=0; col_index<8;col_index++) {
            let cell = row.insertCell();
            cell.classList.add("kenocell");
            let text = document.createTextNode( " " +  (bit_index+1));
            cell.appendChild(text);
            let tempvalue_of_bit_index = bit_index;
            cell.onmousedown = function () {clickHandler( cell ,  tempvalue_of_bit_index   )};
            cell.onmouseenter = function (e) { if (e.buttons & 0x01) clickHandler( cell ,tempvalue_of_bit_index  ) };
            bits[bit_index]=0;
            bit_index++;
            //console.log("bi="+bit_index);
        }
    }
</script>

<!--
    This is a Browserfy'ed version of the popular bitcoinjs package.
    To verify it is trustworthy for yourself, check out /js/bitcoinjs.MD
    We only use it to generate the public ECSDA key and do some formatting.
    Sorry, I could not bring myself to write this stuff in Javascript. If
    you know a clean alternative I can use, please suggest it. I do not
    want to use the subtlecrypto stuff because it has the absurd requirement
    that it will only generate keys when loaded over SSL. This seems like a
    deep misunderstanding of crypto. Please correct me if I am wrong.
-->

<script src="js/bitcoinjs.min.js">
</script>

<script>
    // All Globals here so we can keep track of them
    var network;        // Test or Main
    var keyPair;        // User's keypair
</script>

<script>

    network = bitcoinjs.networks.testnet;
    //network = bitcoinjs.networks.main;

    keyPair = bitcoinjs.ECPair.makeRandom();
    const address1  = bitcoinjs.payments.p2pkh({ pubkey: keyPair.publicKey ,  network  }).address;
    const pubkey = keyPair.publicKey;
    const privateKey = keyPair.privateKey;
    const wif = keyPair.toWIF();
    console.log(pubkey);
    console.log(address1);
    console.log(wif);


    // Lets make a block
    // https://github.com/bitcoinjs/bitcoinjs-lib/blob/master/ts_src/block.ts

    let block= new bitcoinjs.Block();        // Set up all the fields

    // https://developer.bitcoin.org/reference/block_chain.html

    // Lets try this first
    // https://www.blockchain.com/btc/block/000000000000000000039f8b1a2c48ee1dacd581e7cacb560e75d8de051cc0e1
    block.version = Number.parseInt( "2000e000" , 16 );

    block.prevHash = bitcoinjs.buffer.Buffer.from("00000000000000000000120caab7c1caeb4aad6e9dc242e7530d543edd4f6a27","hex").reverse();
    block.merkleRoot = bitcoinjs.buffer.Buffer.from("b847ca78b242364926cd5a11469c8b98864ce1af031f5ed3567041a22a8ac2f5","hex").reverse();
    block.timestamp = 1619825649;
    block.bits = 0x170bef93; //bitcoinjs.buffer.Buffer.from("170bef93","hex");
    block.nonce = 1334528400;

    let blockhex = block.toHex(true);       // True is headers only
    console.log( "block="+blockhex);

    let blockhash= block.getHash();
    let blockhashhex = blockhash.toString("hex");       // True is headers only

    console.log( "blockhash=" + blockhashhex);

    // How can the API not come with this function?!
    bitcoinjs.buffer.Buffer.prototype.writeBuffer = function ( b , o  ) {
        return o+b.copy( this , o  );
    }

    // How can the API not come with this function?!
    bitcoinjs.buffer.Buffer.prototype.fillByte = function ( b , c , o  ) {
        while (c) {
            o=this.writeUInt8( b , o );
            c--;
        }
        return o;
    }


    // Now lets try adding a coinbase transaction to the block
    // Here is an empty block we can use as a template:
    // d8025d52f6d10559f60207f4f9db2545f1935ef69a5b418e9b2ae6e711b654e6
    // It has one transaction:
    // d8025d52f6d10559f60207f4f9db2545f1935ef69a5b418e9b2ae6e711b654e6
    // As raw Hex:
    // https://blockchain.info/tx/d8025d52f6d10559f60207f4f9db2545f1935ef69a5b418e9b2ae6e711b654e6?format=hex
    // 010000000001010000000000000000000000000000000000000000000000000000000000000000ffffffff5403e8650a1b4d696e656420627920416e74506f6f6c37363978002902b7c70781fabe6d6d83410bf4ea571acde5acecff1587f39ff6b027f422575e933acf1043d0ccee3002000000000000009af000001a070000ffffffff0440be4025000000001976a91411dbe48cc6b617f9c6adaf4d9ed5f625b1c7cb5988ac0000000000000000266a24aa21a9ede2f61c3f71d1defd3fa999dfa36953755c690689799962b48bebd836974e8cf90000000000000000266a24b9e11b6d45d19962c0f444142e898f64a94b73324896afa4adfe794cf63e0f3cd521f6df00000000000000002b6a2952534b424c4f434b3a1ba6a546d2bcb116f744b51c4749d02e4fcd6ceb2d158fb5c14b3828003293ec0120000000000000000000000000000000000000000000000000000000000000000000000000
    // 01000000: Version 1
    // 00 : Input count?
    // 01010000000000000000000000000000000000000000000000000000000000000000ffffffff5403e8650a1b4d696e656420627920416e74506f6f6c37363978002902b7c70781fabe6d6d83410bf4ea571acde5acecff1587f39ff6b027f422575e933acf1043d0ccee3002000000000000009af000001a070000ffffffff0440be4025000000001976a91411dbe48cc6b617f9c6adaf4d9ed5f625b1c7cb5988ac0000000000000000266a24aa21a9ede2f61c3f71d1defd3fa999dfa36953755c690689799962b48bebd836974e8cf90000000000000000266a24b9e11b6d45d19962c0f444142e898f64a94b73324896afa4adfe794cf63e0f3cd521f6df00000000000000002b6a2952534b424c4f434b3a1ba6a546d2bcb116f744b51c4749d02e4fcd6ceb2d158fb5c14b3828003293ec0120000000000000000000000000000000000000000000000000000000000000000000000000
    //

    // https://medium.com/@aniketdivekar/bitcoin-create-sign-and-push-transaction-2ea877c08ab4


    // Let's build a raw coinbase transaction from scratch since I can not figure out how to do it in bitcoinjs

    // This is a coinbase input transaction script that just pushes the blockheight on the stack
    function pushHeightScript( height ) {
        let b = bitcoinjs.buffer.Buffer( 256 );     // This is lazy, but I am bad at counting
        let o=0;
        // We need to push the block number on the stack as per BIP-0034
        o=b.writeUInt8( bitcoinjs.opcodes.OP_PUSHDATA1 , o );             // A bit premature, but I am too lazy to write a writeUInt24LE.
        o=b.writeUInt8( 4 , o );                                  // Push 4 bytes of blockheight
        o=b.writeUInt32LE( height , o );                     // Will this work (currently everyone does only 3 bytes)

        // TODO: Put a "Play Hashunt.josh.com" in here.

        return b.slice(0,o);
    }

    // Creates a coinbase input transaction. Takes blockheight as a num. Returns a buffer.
    function coinbaseTx( blockheight ) {
        let b = bitcoinjs.buffer.Buffer( 256 );     // This is lazy, but I am bad at counting
        let o=0;
        o=b.fillByte( 0x00 , 32 , o  );      // source hash - null by convention
        o=b.writeUInt32LE(0xffffffff,o);     // source index - -1 by convention

        // We need to push the block number on the stack as per BIP-0034
        let coinbaseScript = pushHeightScript( blockheight );
        o=b.writeUInt8( coinbaseScript.length ,o);              // script len (the script directly below is 5 bytes
        o=b.writeBuffer( coinbaseScript , o );

        o=b.writeUInt32LE( 0xffffffff ,o);    // Sequence number - seems to always be -1

        console.log("coinbase:");
        console.log("height:" + blockheight );
        console.log( b.slice(0,o).toString("hex"));

        return b.slice(0,o);
    }

    // Creates a single P2PK locking script
    // Takes a buffer with the public key, returns a buffer
    function outScript( pubkey ) {
        let b = bitcoinjs.buffer.Buffer(256);     // This is lazy, but I am bad at counting
        let o = 0;
        // Simplest lock script is to push a publick key and the OP_CHECK sig
        o=b.writeBuffer( pubkey , o );
        o=b.writeUInt8(  bitcoinjs.opcodes.OP_CHECKSIG , o );
        return b.slice(0,o);
    }

    // Create a normal P2PK tx
    // Value is number of satoshis. Must be < 2^32.
    // Pubkey is a buffer with the public key.
    // Returns a buffer.
    function P2PKOut(value , pubkey ) {
        let b = bitcoinjs.buffer.Buffer(256);     // This is lazy, but I am bad at counting
        let o = 0;
        o=b.writeUInt32LE(value , o);           // Write the lower 32 bits of value.
        o=b.writeUInt32LE( 0 , o);              // Full field is 64 bits, so write zeros in upper 32 bits.
        let outscriptBuffer = outScript(pubkey);
        o=b.writeUInt8( bitcoinjs.opcodes.OP_PUSHDATA1 , o );    // The next byte contains the number of bytes to be pushed onto the stack.
        o=b.writeUInt8( outscriptBuffer.length , o);
        o=b.writeBuffer( outscriptBuffer , o );
        return b.slice(0,o);
    }

    // Create a standard  P2PKH lock script
    // Pubkey is a buffer public key
    // Returns a buffer.
    function P2PKHOutScript( pubkey ) {
        let b = bitcoinjs.buffer.Buffer(256);     // This is lazy, but I am bad at counting
        let o = 0;
        // Below is the standard P2PKH script: OP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG
        // Helpful for debugging this.. https://siminchen.github.io/bitcoinIDE/build/editor.html
        // (took 1 hour to figure out that pubkeyhash.len should have been pubkeyhash.length. I hate JS.)

        o=b.writeUInt8( bitcoinjs.opcodes.OP_DUP , o );
        o=b.writeUInt8( bitcoinjs.opcodes.OP_HASH160 , o );

        let pubkeyhash = bitcoinjs.crypto.hash160( pubkey );
        o=b.writeUInt8( bitcoinjs.opcodes.OP_PUSHDATA1 , o );
        o=b.writeUInt8( pubkeyhash.length, o);
        o=b.writeBuffer( pubkeyhash , o );

        o=b.writeUInt8( bitcoinjs.opcodes.OP_EQUALVERIFY , o );
        o=b.writeUInt8( bitcoinjs.opcodes.OP_CHECKSIG , o );

        return b.slice(0,o);
    }

    // Create a normal P2PKH tx
    // value is satoshis
    // Pubkey is a buffer public key
    // Returns a buffer.

    function P2PKHOutTx( value , pubkey ) {
        let b = bitcoinjs.buffer.Buffer(256);     // This is lazy, but I am bad at counting
        let o = 0;

        o=b.writeUInt32LE( value, o);               // Write the lower 32 bits of value in satoshis
        o=b.writeUInt32LE( 0 , o);                  // Full field is 64 bits, so write zeros in upper 32 bits.

        console.log("value:")
        console.log( value.toString( 16) );


        let outTxScript = P2PKHOutScript( pubkey );

        console.log("outTxScript:")
        console.log( outTxScript.toString("hex") );

        o=b.writeUInt8( outTxScript.length , o );              // Out script len
        o=b.writeBuffer( outTxScript , o );

        return b.slice(0,o);
    }


    let b = bitcoinjs.buffer.Buffer( 256 );       // Oversize for now
    let o = 0;

    o=b.writeUInt32LE(0x01 , o );   // Version number. Currently 0x01 based on looking at recent coinbase transactions.

    // First inputs
    o=b.writeUInt8( 0x01  , o );    // Input count
    let inTx = coinbaseTx( 123456 ,o );
    o=b.writeBuffer( inTx , o);

    console.log("after cb:")
    console.log( b.slice(0,o).toString("hex") );

    // Then outputs
    o=b.writeUInt8( 0x01 , o  );     // Output count
    let outTx = P2PKHOutTx( 5 * 1e8  , keyPair.publicKey );
    o=b.writeBuffer( outTx , o  );

    o=b.writeUInt32LE( 0x00000000 , o );        // Locktime

    console.log("TX:");
    console.log( b.slice(0,o).toString("hex") );



</script>



</body>
</html>